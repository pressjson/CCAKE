1c1,2
< #include "eos.h"
---
> #ifndef _EOS_CPP_
> #define _EOS_CPP_
3,15c4,7
< #include "../splinter/include/datatable.h"
< #include "../splinter/include/bspline.h"
< #include "../splinter/include/bsplinebuilder.h"
< 
< #include <gsl/gsl_multiroots.h>
< #include <gsl/gsl_vector.h>
< #include <gsl/gsl_matrix.h>
< #include <gsl/gsl_permutation.h>
< #include <gsl/gsl_blas.h>
< #include <gsl/gsl_linalg.h>
< #include <iostream>
< #include <vector>
< #include <fstream>
---
> # include <cstdlib>
> # include <iostream>
> # include <iomanip>
> # include <cmath>
16a9,10
> #include <stdio.h>
> #include "eostables.h"
18,23c12
< using std::vector;
< using std::string;
< 
< using namespace SPLINTER;
< 
< // Compile:         gcc eos4D.cpp -c -I /usr/include/eigen3 -Lsplinter/build -lm -lgsl -lgslcblas -lstdc++ -lsplinter-3-0
---
> using namespace std;
24a14,15
> //#include "fadiff.h"
> //using namespace fadbad;
26,139d16
< //EoS constructor. Builds the splines of degree "degree" for each quantitiy and initializes the position at (30,0,0,0)
< eos::eos(string quantityFile, string derivFile, int degree) : pSpline(4), entrSpline(4), bSpline(4), sSpline(4), qSpline(4), eSpline(4), cs2Spline(4), db2Spline(4), dq2Spline(4), ds2Spline(4), dt2Spline(4), dbdqSpline(4), dbdsSpline(4), dtdbSpline(4), dqdsSpline(4), dtdqSpline(4), dtdsSpline(4), tbqsPosition(4) {
<     init(quantityFile, derivFile, degree);
< }
< 
< //EoS default constructor. This function exists to satisfy the compiler
< //This function should never be called unless init is called directly afterward
< eos::eos() : pSpline(4), entrSpline(4), bSpline(4), sSpline(4), qSpline(4), eSpline(4), cs2Spline(4), db2Spline(4), dq2Spline(4), ds2Spline(4), dt2Spline(4), dbdqSpline(4), dbdsSpline(4), dtdbSpline(4), dqdsSpline(4), dtdqSpline(4), dtdsSpline(4), tbqsPosition(4) {}
< 
< void eos::init(string quantityFile, string derivFile, int degree) {
<     std::ifstream dataFile;
<     std::ifstream derFile;
<     dataFile.open(quantityFile);
<     derFile.open(derivFile);
< 
<     DataTable psamples, entrsamples, bsamples, ssamples, qsamples, esamples, cs2samples;
<     DataTable db2samples, ds2samples, dq2samples, dt2samples, dbdssamples, dbdqsamples, dqdssamples, dtdssamples, dtdqsamples, dtdbsamples;
< 
<     double tit, muBit, muQit, muSit, pit, entrit, bit, sit, qit, eit, cs2it;
<     double db2it, dq2it, ds2it, dt2it, dbdqit, dbdsit, dqdsit, dtdbit, dtdsit, dtdqit;
<     vector<double> toAdd;
< 
<     int count = 0;
<     double hbarc = 197.327;
<     while (dataFile >> tit >> muBit >> muQit >> muSit >> pit >> entrit >> bit >> sit >> qit >> eit >> cs2it) {
<         derFile >> tit >> muBit >> muQit >> muSit >> db2it >> dq2it >> ds2it >> dbdqit >> dbdsit >> dqdsit >> dtdbit >> dtdqit >> dtdsit >> dt2it;  //read data from files
<         if(count == 0) {
<             minT = tit;
<             maxT = tit;
<             minMuB = muBit;
<             maxMuB = muBit;     //initilaize eos range variables
<             minMuQ = muQit;
<             maxMuQ = muQit;
<             minMuS = muSit;
<             maxMuS = muSit;
<             ++count;
<         }
<         if(maxT < tit) {
<             maxT = tit;
<         }
<         if(minT > tit) {
<             minT = tit;
<         }
<         if(maxMuB < muBit) {
<             maxMuB = muBit;
<         }
<         if(minMuB > muBit) {
<             minMuB = muBit;
<         }
<         if(maxMuQ < muQit) {
<             maxMuQ = muQit;
<         }
<         if(minMuQ > muQit) {
<             minMuQ = muQit;
<         }
<         if(maxMuS < muSit) {
<             maxMuS = muSit;
<         }
<         if(minMuS > muSit) {
<             minMuS = muSit;
<         }
< 
<         toAdd.push_back(tit);
<         toAdd.push_back(muBit);
<         toAdd.push_back(muQit);
<         toAdd.push_back(muSit);
< 
<         pit = pit*(tit*tit*tit*tit)/(hbarc*hbarc*hbarc);
<         entrit = entrit*(tit*tit*tit)/(hbarc*hbarc*hbarc);
<         bit = bit*(tit*tit*tit)/(hbarc*hbarc*hbarc);
<         sit = sit*(tit*tit*tit)/(hbarc*hbarc*hbarc);        //convert to MeV and fm units
<         qit = qit*(tit*tit*tit)/(hbarc*hbarc*hbarc);
<         eit = eit*(tit*tit*tit*tit)/(hbarc*hbarc*hbarc);
< 
<         psamples.addSample(toAdd, pit);
<         entrsamples.addSample(toAdd, entrit);
<         bsamples.addSample(toAdd, bit);
<         ssamples.addSample(toAdd, sit);
<         qsamples.addSample(toAdd, qit);
<         esamples.addSample(toAdd, eit);
<         cs2samples.addSample(toAdd, cs2it);
<         db2samples.addSample(toAdd, db2it);
<         dq2samples.addSample(toAdd, dq2it);     //add datapoint to table for spline builder
<         ds2samples.addSample(toAdd, ds2it);
<         dbdqsamples.addSample(toAdd, dbdqit);
<         dbdssamples.addSample(toAdd, dbdsit);
<         dqdssamples.addSample(toAdd, dqdsit);
<         dtdbsamples.addSample(toAdd, dtdbit);
<         dtdqsamples.addSample(toAdd, dtdqit);
<         dtdssamples.addSample(toAdd, dtdsit);
<         dt2samples.addSample(toAdd, dt2it);
<         toAdd.clear();
<     }
< 
<     dataFile.close();
<     derFile.close();
<     
<     pSpline = BSpline::Builder(psamples).degree(degree).build();
<     entrSpline = BSpline::Builder(entrsamples).degree(degree).build();
<     bSpline = BSpline::Builder(bsamples).degree(degree).build();
<     sSpline = BSpline::Builder(ssamples).degree(degree).build();
<     qSpline = BSpline::Builder(qsamples).degree(degree).build();
<     eSpline = BSpline::Builder(esamples).degree(degree).build();
<     cs2Spline = BSpline::Builder(cs2samples).degree(degree).build();
<     db2Spline = BSpline::Builder(db2samples).degree(degree).build();
<     dq2Spline = BSpline::Builder(dq2samples).degree(degree).build();
<     ds2Spline = BSpline::Builder(ds2samples).degree(degree).build();        //make splines from table
<     dbdqSpline = BSpline::Builder(dbdqsamples).degree(degree).build();
<     dbdsSpline = BSpline::Builder(dbdssamples).degree(degree).build();
<     dqdsSpline = BSpline::Builder(dqdssamples).degree(degree).build();
<     dtdbSpline = BSpline::Builder(dtdbsamples).degree(degree).build();
<     dtdqSpline = BSpline::Builder(dtdqsamples).degree(degree).build();
<     dtdsSpline = BSpline::Builder(dtdssamples).degree(degree).build();
<     dt2Spline = BSpline::Builder(dt2samples).degree(degree).build();
141,142c18,21
<     return;
< }
---
> # include "newspline.hpp"
> #include "tables.h"
> #include "eos.h"
> #include <float.h>
144,181c23,37
< void eos::tbqs(double setT, double setmuB, double setmuQ, double setmuS) {
<     if(setT < minT || setT > maxT) {
<         std::cout << "T = " << setT << " is out of range. Valid values are between [" << minT << "," << maxT << "]" << std::endl;
<         return;
<     }
<     if(setmuB < minMuB || setmuB > maxMuB) {
<         std::cout << "muB = " << setmuB << " is out of range. Valid values are between [" << minMuB << "," << maxMuB << "]" << std::endl;
<         return;
<     }
<     if(setmuQ < minMuQ || setmuQ > maxMuQ) {
<         std::cout << "muQ = " << setmuQ << " is out of range. Valid values are between [" << minMuQ << "," << maxMuQ << "]" << std::endl;
<         return;
<     }
<     if(setmuS < minMuS || setmuS > maxMuS) {
<         std::cout << "muS = " << setmuS << " is out of range. Valid values are between [" << minMuS << "," << maxMuS << "]" << std::endl;
<         return;
<     }
<     tbqsPosition(0) = setT;
<     tbqsPosition(1) = setmuB;
<     tbqsPosition(2) = setmuQ;
<     tbqsPosition(3) = setmuS;
<     
<     pVal = pSpline.eval(tbqsPosition);
<     BVal = bSpline.eval(tbqsPosition);
<     SVal = sSpline.eval(tbqsPosition);
<     QVal = qSpline.eval(tbqsPosition);
<     eVal = eSpline.eval(tbqsPosition);
<     cs2Val = cs2Spline.eval(tbqsPosition);
<     db2 = db2Spline.eval(tbqsPosition);
<     ds2 = ds2Spline.eval(tbqsPosition);
<     dq2 = dq2Spline.eval(tbqsPosition);
<     dt2 = dt2Spline.eval(tbqsPosition);
<     dbdq = dbdqSpline.eval(tbqsPosition);
<     dbds = dbdsSpline.eval(tbqsPosition);
<     dsdq = dqdsSpline.eval(tbqsPosition);
<     dtdb = dtdbSpline.eval(tbqsPosition);
<     dtds = dtdsSpline.eval(tbqsPosition);
<     dtdq = dtdqSpline.eval(tbqsPosition);
---
> eos::eos()
> {
> 	gg=3.297572;
> 	c=(16. +  7./2. *7.5 )/90. *cPI*cPI;
> 	cs=4./3.*pow(3.*c,0.25);
> 	cp=1./pow((4.*pow(c,0.25)),(4./3.));
> 	cp2=16./3.*cp;
> 	tempcutoff=65/197.3;
> 	ds1=-gg*pow(mpi,4)/(4.*cPI*cPI);
> 	es2=gg*pow(mpi,4)/(2.*cPI*cPI);
> 	es1=es2*3;
> 	ps1=gg/(2.*cPI*cPI);
> 	fourthirds=4./3.;
> 	onethird=1./3.;
> 	BIG=pow(1.,30.);
183,184c39
<     entrVal = (eVal + pVal - setmuB*BVal - setmuQ*QVal - setmuS*SVal)/setT;
< }
---
> };
186,188c41,53
< double eos::p() {
<     return pVal;
< }
---
> double eos::efreeze()
> {
> 	temp=freezeoutT;
> 	double echeckout;
> 	if (typerem==table)
> 	{
> 		echeckout=spline(r8_T,y_e,temp,pos);
> 	}
> 	else if (typerem==ideal)
> 	{
> 		echeckout=3*c*pow(temp,4);
> 	}
> 	return echeckout;
190,192c55
< double eos::s() {
<     return entrVal;
< }
---
> };
194,196d56
< double eos::B() {
<     return BVal;
< }
198,200c58,71
< double eos::S() {
<     return SVal;
< }
---
> double eos::sfreeze()
> {
>   temp=freezeoutT;
>   double scheckout;
>   if (typerem==table)
>     {
>       scheckout=spline(r8_T,y_s,temp,pos);
>     }
>   else if (typerem==ideal)
>     {
>       cout << "must setup still in EOS" << endl;
>       exit(1);
>     }
>   return scheckout;
202,204c73
< double eos::Q() {
<     return QVal;
< }
---
> };
206,208c75,76
< double eos::e() {
<     return eVal;
< }
---
> double eos::s_terms_T(double Tt)
> {
210,212c78,93
< double eos::cs2() {
<     return cs2Val;
< }
---
> 	double etout,ptout;
> 	if (typerem==table)
> 	{
> 		if (Tt>ETH[0].T)
> 		{
> 		etout=spline(r8_T,y_e,Tt,pos);
> 		ptout=splinepos(y_T,y_p,Tt,pos);
> 		}
> 		else
> 		{
> 		etout=spline(r8_Tlow,y_elow,Tt,pos);
> 		ptout=splinepos(y_Tlow,y_plow,Tt,pos);
> 		}
> 	}
> 	else if (typerem==ideal)
> 	{
213a95,98
> 		ptout=c*pow(Tt,4);
> 		etout=3*ptout;
> 	}
> 	return (etout+ptout)/Tt;
215,217c100
< double eos::w() {
<     return eVal + pVal;
< }
---
> };
218a102,108
> double eos::cs2out(double Tt)
> {
> 	double out;
> 	if (typerem==table)
> 	{
> 		double Ttsub=Tt+0.0001;
> 		double ee1,ee2,pp1,pp2;
219a110,113
> 		if (Tt<ETH[0].T)
> 		{
> 		ee1=spline(r8_Tlow,y_elow,Tt,pos);
> 		pp1=splinepos(y_Tlow,y_plow,Tt,pos);
221,223c115,116
< double eos::T() {
<     return tbqsPosition(0);
< }
---
> 		ee2=spline(r8_Tlow,y_elow,Ttsub,pos);
> 		pp2=splinepos(y_Tlow,y_plow,Ttsub,pos);
225,227c118,122
< double eos::muB() {
<     return tbqsPosition(1);
< }
---
> 		}
> 		else 
> 		{
> 		ee1=spline(r8_T,y_e,Tt,pos);
> 		pp1=splinepos(y_T,y_p,Tt,pos);
229,231c124,125
< double eos::muQ() {
<     return tbqsPosition(2);
< }
---
> 		ee2=spline(r8_T,y_e,Ttsub,pos);
> 		pp2=splinepos(y_T,y_p,Ttsub,pos);
233,235c127,134
< double eos::muS() {
<     return tbqsPosition(3);
< }
---
> 		}
> 		out=(pp2-pp1)/(ee2-ee1);
> 	}
> 	else if (typerem==ideal)
> 	{
> 		out=1./3.;
> 	}
> 	return out;
236a136
> };
237a138,149
> double eos::wfz(double Tt)
> {
> 	double out;
> 	if (typerem==table)
> 	{
> 		out=spline(r8_T,y_e,Tt,pos)+spline(r8_T,y_p,Tt,pos);
> 	}
> 	else if (typerem==ideal)
> 	{
> 		out=4*c*pow(Tt,4.);
> 	}
> 	return out;
239,241c151
< double eos::dwds() {
<     return T() + entrVal/dentr_dt() + BVal/dentr_dmub() + QVal/dentr_dmuq() + SVal/dentr_dmus();
< }
---
> };
243,245d152
< double eos::dwdB() {
<     return muB() + entrVal/db_dt() + BVal/db_dmub() + QVal/db_dmuq() + SVal/db_dmus();
< }
247,249c154,162
< double eos::dwdS() {
<     return muS() + entrVal/ds_dt() + BVal/ds_dmub() + QVal/ds_dmuq() + SVal/ds_dmus();
< }
---
> double eos::s_out(double eIC)
> {
> 	double entro;
> 	if (typerem==ideal)
> 	{
> 		entro=cs*pow(eIC,0.75); 
> 	}
> 	else if (typerem==table)
> 	{
251,253c164,169
< double eos::dwdQ() {
<     return muQ() + entrVal/dq_dt() + BVal/dq_dmub() + QVal/dq_dmuq() + SVal/dq_dmus();
< }
---
> 		if (eIC>echeck)
> 		{
> 			entro=spline(r8_e,y_s,eIC,pos);
> 		}
> 		else 
> 		{
255,257c171,173
< double eos::dentr_dt() {
<     return calc_term_1();
< }
---
> 			entro=spline(r8_elow,y_slow,eIC,pos);
> 		}
> 	}
259,260c175
< double eos::dentr_dmub() {
<     return calc_term_2("b");
---
> 	return entro;
263,265c178,186
< double eos::dentr_dmuq() {
<     return calc_term_2("q");
< }
---
> double eos::e_out(double sIC)
> {
>   double ent;
>   if (typerem==ideal)
>     {
>       ent=pow(sIC/cs,4./3.); 
>     }
>   else if (typerem==table)
>     {
267,269c188,193
< double eos::dentr_dmus() {
<     return calc_term_2("s");
< }
---
>       if (sIC>scheck)
> 	{
> 	  ent=spline(r8_s,y_e,sIC,pos);
> 	}
>       else 
> 	{
271,273c195,197
< double eos::db_dt() {
<     return calc_term_3("b");
< }
---
> 	  ent=spline(r8_slow,y_elow,sIC,pos);
> 	}
>     }
275,276c199
< double eos::db_dmub() {
<     return calc_term_4("b","b");
---
>   return ent;
279,281c202,204
< double eos::db_dmuq() {
<     return calc_term_4("b","q");
< }
---
> void eos::pressure_ideal()
> {
> 	 pressure=pow( entropy,fourthirds)*cp;	 
283,284d205
< double eos::db_dmus() {
<     return calc_term_4("b","s");
287,289d207
< double eos::ds_dt() {
<     return calc_term_3("s");
< }
291,293c209,210
< double eos::ds_dmub() {
<     return calc_term_4("s","b");
< }
---
> void eos::energy_ideal()
> {
295,297c212,213
< double eos::ds_dmuq() {
<     return calc_term_4("s","q");
< }
---
> 	energy=3*pressure;
> };
299,301c215,216
< double eos::ds_dmus() {
<     return calc_term_4("s","s");
< }
---
> void eos::temp_ideal()
> {
303,305c218,219
< double eos::dq_dt() {
<     return calc_term_3("q");
< }
---
> 	 temp=(energy+pressure)/entropy;
> };
307,309c221,222
< double eos::dq_dmub() {
<     return calc_term_4("q","b");
< }
---
> void eos::eosin(string type)
> {
311,313c224
< double eos::dq_dmuq() {
<     return calc_term_4("q","q");
< }
---
> 	typerem=type;
315,317c226,227
< double eos::dq_dmus() {
<     return calc_term_4("q","s");
< }
---
> 	ideal="ideal";
> 	table="table";
319,342d228
< double eos::calc_term_1() {
<     gsl_vector *v = gsl_vector_alloc(3);
<     gsl_matrix *m = gsl_matrix_alloc(3,3);
< 
<     gsl_vector_set(v,0,dtdb);
<     gsl_vector_set(v,1,dtds);
<     gsl_vector_set(v,2,dtdq);
< 
<     gsl_matrix_set(m,0,0,db2);
<     gsl_matrix_set(m,0,1,dbds);
<     gsl_matrix_set(m,0,2,dbdq);
<     gsl_matrix_set(m,1,0,dbds);
<     gsl_matrix_set(m,1,1,ds2);
<     gsl_matrix_set(m,1,2,dsdq);
<     gsl_matrix_set(m,2,0,dbdq);
<     gsl_matrix_set(m,2,1,dsdq);
<     gsl_matrix_set(m,2,2,dq2);
< 
<     double toReturn = dt2 - deriv_mult_aTm_1b(v,m,v);
< 
<     gsl_matrix_free(m);
<     gsl_vector_free(v);
<     return toReturn;
< }
344,418d229
< double eos::calc_term_2(string i_char) {
<     gsl_vector *a = gsl_vector_alloc(3);
<     gsl_matrix *m = gsl_matrix_alloc(3,3);
<     gsl_vector *b = gsl_vector_alloc(3);
<     double toReturn = 0;
< 
<     if (i_char == "b") {
<         gsl_vector_set(a,0,dt2);
<         gsl_vector_set(a,1,dtds);
<         gsl_vector_set(a,2,dtdq);
< 
<         gsl_vector_set(b,0,db2);
<         gsl_vector_set(b,1,dbds);
<         gsl_vector_set(b,2,dbdq);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,dbds);
<         gsl_matrix_set(m,0,2,dbdq);
<         gsl_matrix_set(m,1,0,dtds);
<         gsl_matrix_set(m,1,1,ds2);
<         gsl_matrix_set(m,1,2,dsdq);
<         gsl_matrix_set(m,2,0,dtdq);
<         gsl_matrix_set(m,2,1,dsdq);
<         gsl_matrix_set(m,2,2,dq2);
< 
<         toReturn = dtdb - deriv_mult_aTm_1b(a,m,b);
<     } else if (i_char == "s") {
<         gsl_vector_set(a,0,dt2);
<         gsl_vector_set(a,1,dtdb);
<         gsl_vector_set(a,2,dtdq);
< 
<         gsl_vector_set(b,0,dbds);
<         gsl_vector_set(b,1,ds2);
<         gsl_vector_set(b,2,dsdq);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,db2);
<         gsl_matrix_set(m,0,2,dbdq);
<         gsl_matrix_set(m,1,0,dtds);
<         gsl_matrix_set(m,1,1,dbds);
<         gsl_matrix_set(m,1,2,dsdq);
<         gsl_matrix_set(m,2,0,dtdq);
<         gsl_matrix_set(m,2,1,dbdq);
<         gsl_matrix_set(m,2,2,dq2);
< 
<         toReturn = dtds - deriv_mult_aTm_1b(a,m,b);
<     } else if (i_char == "q") {
<         gsl_vector_set(a,0,dt2);
<         gsl_vector_set(a,1,dtdb);
<         gsl_vector_set(a,2,dtds);
< 
<         gsl_vector_set(b,0,dbdq);
<         gsl_vector_set(b,1,dsdq);
<         gsl_vector_set(b,2,dq2);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,db2);
<         gsl_matrix_set(m,0,2,dbdq);
<         gsl_matrix_set(m,1,0,dtds);
<         gsl_matrix_set(m,1,1,dbds);
<         gsl_matrix_set(m,1,2,dsdq);
<         gsl_matrix_set(m,2,0,dtdq);
<         gsl_matrix_set(m,2,1,dbdq);
<         gsl_matrix_set(m,2,2,dq2);
< 
<         toReturn = dtdq - deriv_mult_aTm_1b(a,m,b);
<     } else {
<         std::cout << "Error calculating derivative term 2" << std::endl;
<     }
< 
<     gsl_vector_free(a);
<     gsl_matrix_free(m);
<     gsl_vector_free(b);
<     return toReturn;
< }
420,494d230
< double eos::calc_term_3(string i_char) {
<     gsl_vector *a = gsl_vector_alloc(3);
<     gsl_matrix *m = gsl_matrix_alloc(3,3);
<     gsl_vector *b = gsl_vector_alloc(3);
<     double toReturn = 0;
< 
<     if (i_char == "b") {
<         gsl_vector_set(a,0,db2);
<         gsl_vector_set(a,1,dbds);
<         gsl_vector_set(a,2,dbdq);
< 
<         gsl_vector_set(b,0,dt2);
<         gsl_vector_set(b,1,dtds);
<         gsl_vector_set(b,2,dtdq);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,dtds);
<         gsl_matrix_set(m,0,2,dtdq);
<         gsl_matrix_set(m,1,0,dbds);
<         gsl_matrix_set(m,1,1,ds2);
<         gsl_matrix_set(m,1,2,dsdq);
<         gsl_matrix_set(m,2,0,dbdq);
<         gsl_matrix_set(m,2,1,dsdq);
<         gsl_matrix_set(m,2,2,dq2);
< 
<         toReturn = dtdb - deriv_mult_aTm_1b(a,m,b);
<     } else if (i_char == "s") {
<         gsl_vector_set(a,0,dbds);
<         gsl_vector_set(a,1,ds2);
<         gsl_vector_set(a,2,dsdq);
< 
<         gsl_vector_set(b,0,dt2);
<         gsl_vector_set(b,1,dtdb);
<         gsl_vector_set(b,2,dtdq);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,dtds);
<         gsl_matrix_set(m,0,2,dtdq);
<         gsl_matrix_set(m,1,0,db2);
<         gsl_matrix_set(m,1,1,dbds);
<         gsl_matrix_set(m,1,2,dbdq);
<         gsl_matrix_set(m,2,0,dbdq);
<         gsl_matrix_set(m,2,1,dsdq);
<         gsl_matrix_set(m,2,2,dq2);
< 
<         toReturn = dtds - deriv_mult_aTm_1b(a,m,b);
<     } else if (i_char == "q") {
<         gsl_vector_set(a,0,dbdq);
<         gsl_vector_set(a,1,dsdq);
<         gsl_vector_set(a,2,dq2);
< 
<         gsl_vector_set(b,0,dt2);
<         gsl_vector_set(b,1,dtdb);
<         gsl_vector_set(b,2,dtds);
<         
<         gsl_matrix_set(m,0,0,dtdb);
<         gsl_matrix_set(m,0,1,dtds);
<         gsl_matrix_set(m,0,2,dtdq);
<         gsl_matrix_set(m,1,0,db2);
<         gsl_matrix_set(m,1,1,dbds);
<         gsl_matrix_set(m,1,2,dbdq);
<         gsl_matrix_set(m,2,0,dbds);
<         gsl_matrix_set(m,2,1,ds2);
<         gsl_matrix_set(m,2,2,dsdq);
< 
<         toReturn = dtdq - deriv_mult_aTm_1b(a,m,b);
<     } else {
<         std::cout << "Error calculating derivative term 3" << std::endl;
<     }
< 
<     gsl_vector_free(a);
<     gsl_matrix_free(m);
<     gsl_vector_free(b);
<     return toReturn;
< }
496,702c232,238
< double eos::calc_term_4(string j_char, string i_char) {
<     gsl_vector *a = gsl_vector_alloc(3);
<     gsl_matrix *m = gsl_matrix_alloc(3,3);
<     gsl_vector *b = gsl_vector_alloc(3);
<     double toReturn = 0;
< 
<     if (i_char == "b") {
<         if(j_char == "b") {
<             gsl_vector_set(a,0,dtdb);
<             gsl_vector_set(a,1,dbds);
<             gsl_vector_set(a,2,dbdq);
< 
<             gsl_vector_set(b,0,dtdb);
<             gsl_vector_set(b,1,dbds);
<             gsl_vector_set(b,2,dbdq);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtds);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtds);
<             gsl_matrix_set(m,1,1,ds2);
<             gsl_matrix_set(m,1,2,dsdq);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dsdq);
<             gsl_matrix_set(m,2,2,dq2);
< 
<             toReturn = db2 - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "s") {
<             gsl_vector_set(a,0,dtds);
<             gsl_vector_set(a,1,ds2);
<             gsl_vector_set(a,2,dsdq);
< 
<             gsl_vector_set(b,0,dtdb);
<             gsl_vector_set(b,1,db2);
<             gsl_vector_set(b,2,dbdq);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtds);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,dbds);
<             gsl_matrix_set(m,1,2,dbdq);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dsdq);
<             gsl_matrix_set(m,2,2,dq2);
< 
<             toReturn = dbds - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "q") {
<             gsl_vector_set(a,0,dtdq);
<             gsl_vector_set(a,1,dsdq);
<             gsl_vector_set(a,2,dq2);
< 
<             gsl_vector_set(b,0,dtdb);
<             gsl_vector_set(b,1,db2);
<             gsl_vector_set(b,2,dbds);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtds);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,dbds);
<             gsl_matrix_set(m,1,2,dbdq);
<             gsl_matrix_set(m,2,0,dtds);
<             gsl_matrix_set(m,2,1,ds2);
<             gsl_matrix_set(m,2,2,dsdq);
< 
<             toReturn = dbdq - deriv_mult_aTm_1b(a,m,b);
<         } else {
<             std::cout << "Error calculating derivative term 4" << std::endl;
<         }
<     } else if (i_char == "s") {
<         if(j_char == "b") {
<             gsl_vector_set(a,0,dtdb);
<             gsl_vector_set(a,1,db2);
<             gsl_vector_set(a,2,dbdq);
< 
<             gsl_vector_set(b,0,dtds);
<             gsl_vector_set(b,1,ds2);
<             gsl_vector_set(b,2,dsdq);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtds);
<             gsl_matrix_set(m,1,1,dbds);
<             gsl_matrix_set(m,1,2,dsdq);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dbdq);
<             gsl_matrix_set(m,2,2,dq2);
< 
<             toReturn = dbds - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "s") {
<             gsl_vector_set(a,0,dtds);
<             gsl_vector_set(a,1,dbds);
<             gsl_vector_set(a,2,dsdq);
< 
<             gsl_vector_set(b,0,dtds);
<             gsl_vector_set(b,1,dbds);
<             gsl_vector_set(b,2,dsdq);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,db2);
<             gsl_matrix_set(m,1,2,dbdq);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dbdq);
<             gsl_matrix_set(m,2,2,dq2);
< 
<             toReturn = ds2 - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "q") {
<             gsl_vector_set(a,0,dtdq);
<             gsl_vector_set(a,1,dbdq);
<             gsl_vector_set(a,2,dq2);
< 
<             gsl_vector_set(b,0,dtds);
<             gsl_vector_set(b,1,dbds);
<             gsl_vector_set(b,2,ds2);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtdq);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,db2);
<             gsl_matrix_set(m,1,2,dbdq);
<             gsl_matrix_set(m,2,0,dtds);
<             gsl_matrix_set(m,2,1,dbds);
<             gsl_matrix_set(m,2,2,dsdq);
< 
<             toReturn = dsdq - deriv_mult_aTm_1b(a,m,b);
<         } else {
<             std::cout << "Error calculating derivative term 4" << std::endl;
<         }
<     } else if (i_char == "q") {
<         if(j_char == "b") {
<             gsl_vector_set(a,0,dtdb);
<             gsl_vector_set(a,1,db2);
<             gsl_vector_set(a,2,dbds);
< 
<             gsl_vector_set(b,0,dtdq);
<             gsl_vector_set(b,1,dsdq);
<             gsl_vector_set(b,2,dq2);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtds);
<             gsl_matrix_set(m,1,0,dtds);
<             gsl_matrix_set(m,1,1,dbds);
<             gsl_matrix_set(m,1,2,ds2);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dbdq);
<             gsl_matrix_set(m,2,2,dsdq);
< 
<             toReturn = dbdq - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "s") {
<             gsl_vector_set(a,0,dtds);
<             gsl_vector_set(a,1,dbds);
<             gsl_vector_set(a,2,ds2);
< 
<             gsl_vector_set(b,0,dtdq);
<             gsl_vector_set(b,1,dbdq);
<             gsl_vector_set(b,2,dq2);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtds);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,db2);
<             gsl_matrix_set(m,1,2,dbds);
<             gsl_matrix_set(m,2,0,dtdq);
<             gsl_matrix_set(m,2,1,dbdq);
<             gsl_matrix_set(m,2,2,dsdq);
< 
<             toReturn = dsdq - deriv_mult_aTm_1b(a,m,b);
<         } else if (j_char == "q") {
<             gsl_vector_set(a,0,dtdq);
<             gsl_vector_set(a,1,dbdq);
<             gsl_vector_set(a,2,dsdq);
< 
<             gsl_vector_set(b,0,dtdq);
<             gsl_vector_set(b,1,dbdq);
<             gsl_vector_set(b,2,dsdq);
<             
<             gsl_matrix_set(m,0,0,dt2);
<             gsl_matrix_set(m,0,1,dtdb);
<             gsl_matrix_set(m,0,2,dtds);
<             gsl_matrix_set(m,1,0,dtdb);
<             gsl_matrix_set(m,1,1,db2);
<             gsl_matrix_set(m,1,2,dbds);
<             gsl_matrix_set(m,2,0,dtds);
<             gsl_matrix_set(m,2,1,dbds);
<             gsl_matrix_set(m,2,2,ds2);
< 
<             toReturn = dq2 - deriv_mult_aTm_1b(a,m,b);
<         } else {
<             std::cout << "Error calculating derivative term 4" << std::endl;
<         }
<     } else {
<         std::cout << "Error calculating derivative term 4" << std::endl;
<     }
< 
<     gsl_vector_free(a);
<     gsl_matrix_free(m);
<     gsl_vector_free(b);
<     return toReturn;
< }
---
> 	if (type==table)
> 	{
> 		typerem=table;
> 		scheck=ETH[0].s+(ETH[1].s-ETH[0].s)/10000000;
> 		echeck=ETH[0].e+(ETH[1].e-ETH[0].e)/10000000;
> 	}
> 	else typerem="ideal";
704,706c240
< double eos::deriv_mult_aTm_1b(gsl_vector* a, gsl_matrix* m, gsl_vector* b) {
<     gsl_permutation *p = gsl_permutation_alloc(3);
<     int s;
---
> };
708,709d241
<     // Compute the LU decomposition of this matrix
<     gsl_linalg_LU_decomp(m, p, &s);
711,713d242
<     // Compute the  inverse of the LU decomposition
<     gsl_matrix *minv = gsl_matrix_alloc(3, 3);
<     gsl_linalg_LU_invert(m, p, minv);
715d243
<     gsl_vector *y = gsl_vector_alloc(3);
717,718c245,246
<     // Compute y = m^-1 @ b
<     gsl_blas_dgemv(CblasNoTrans,1,m,b,0,y);
---
> void eos::temp_tab()
> {
720,722c248
<     double toReturn = 0;
<     //compute toReturn = aT @ y
<     gsl_blas_ddot(a,y,&toReturn);
---
>    temp=spline(r8_s,y_T,entropy,pos);
724,726c250
<     gsl_vector_free(y);
<     gsl_matrix_free(minv);
<     gsl_permutation_free(p);
---
> }
728c252,254
<     return toReturn;
---
> void eos::pressure_tab()
> {
>    pressure =splinepos(y_T,y_p,temp,pos);	
730a257,261
> void eos::energy_tab()
> {
>    energy = splinepos(y_T,y_e,temp,pos);
> };
> 
733c264
< 	Aout=w()-entrVal*dwds();
---
> 	Aout=w()-entropy*dwds();
738,759c269,270
< double eos::cs2out(double Tt, double muBin, double muQin, double muSin) {  //return cs2 given t and mu's
<     tbqs(Tt, muBin, muQin, muSin);
<     return cs2Val;
< } 
< 
< double eos::wfz(double Tt, double muBin, double muQin, double muSin) {   // return e + p for tbqs
<     tbqs(Tt, muBin, muQin, muSin);
<     return eVal + pVal;
< }
< 
< bool eos::update_s(double sin, double Bin, double Sin, double Qin) { //update the t and mu position based on input. Returns 1 if found, returns 0 if failed
<     if (rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
<     double t0 = tbqsPosition(0);
<     double mub0 = tbqsPosition(1);
<     double muq0 = tbqsPosition(2);
<     double mus0 = tbqsPosition(3);
<     double t10 = t0*.2;
<     double muB10 = mub0*.2;
<     double muQ10 = muq0*.2;
<     double muS10 = mus0*.2;
---
> double eos::dwds_tab()
> {
761,773c272,275
<     //perturb T
<     if(t0 + t10 > maxT) {
<         tbqs(maxT - 1, mub0, muq0, mus0);
<     } else {
<         tbqs(t0 + t10, mub0, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
<     if(t0 - t10 < minT) {
<         tbqs(minT + 1, mub0, muq0, mus0);
<     } else {
<         tbqs(t0 - t10, mub0, muq0, mus0);
---
> 	double dwdstab;
> 	if (entropy<scheck) 
> 	{
> 	dwdstab=splinepos(y_Tlow,y_dtdslow,temp,pos);
775,776c277,279
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
---
> 	else
> 	{ 
> 	dwdstab=splinepos(y_T,y_dtds,temp,pos);
779,795d281
<     //perturb mub
<     if(mub0 + muB10 > maxMuB) {
<         tbqs(t0, maxMuB - 1, muq0, mus0);
<     } else {
<         tbqs(t0, mub0 + muB10, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
<     if(mub0 - muB10 < minMuB) {
<         tbqs(t0, minMuB + 1, muq0, mus0);
<     } else {
<         tbqs(t0, mub0 - muB10, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
797,813d282
<     //perturn muq
<     if(muq0 + muQ10 > maxMuQ) {
<         tbqs(t0, mub0, maxMuQ - 1, mus0);
<     } else {
<         tbqs(t0, mub0, muq0 + muQ10, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
<     if(muq0 - muQ10 < minMuQ) {
<         tbqs(t0, mub0, minMuQ + 1, mus0);
<     } else {
<         tbqs(t0, mub0, muq0 - muQ10, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
815,831c284,286
<     //perturb mus
<     if(mus0 + muS10 > maxMuS) {
<         tbqs(t0, mub0, muq0, maxMuS - 1);
<     } else {
<         tbqs(t0, mub0, muq0, mus0 + muS10);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
<     if(mus0 - muS10 < maxMuS) {
<         tbqs(t0, mub0, muq0, minMuS + 1);
<     } else {
<         tbqs(t0, mub0, muq0, mus0 - muS10);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
---
> 	//dtds is actually T+s*dtds
> 	return dwdstab;
> };
833,837c288,289
<     //check mu = 0
<     tbqs(t0, 0, 0, 0);
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return true;
<     }
---
> void eos::outpos()
> {
839,841c291
<     tbqs(t0, mub0, muq0, mus0);
<     return false;
< }  
---
> 	cout << pos << " " << entropy << " " << scheck << endl;
843c293
< //double eos::s_out(double ein, double Bin, double Sin, double Qin) {   //update the t and mu position based on input. Returns entropy if found, returns -1 if failed
---
> };
845,850c295,298
< // first argument changed ein --> sin by C. Plumberg
< double eos::s_out(double sin, double Bin, double Sin, double Qin) {   //update the t and mu position based on input. Returns entropy if found, returns -1 if failed
<     if (rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
< if (true){std::cerr << "Fix this! " <<__FILE__ << ":" << __LINE__ << std::endl;  exit(8);}
---
> double eos::dwds_ideal()
> {
> 	return 4/3.*temp;
> };
852,859d299
<     double t0 = tbqsPosition(0);
<     double mub0 = tbqsPosition(1);
<     double muq0 = tbqsPosition(2);
<     double mus0 = tbqsPosition(3);
<     double t10 = t0*.2;
<     double muB10 = mub0*.2;
<     double muQ10 = muq0*.2;
<     double muS10 = mus0*.2;
861,877c301,303
<     //perturb T
<     if(t0 + t10 > maxT) {
<         tbqs(maxT - 1, mub0, muq0, mus0);
<     } else {
<         tbqs(t0 + t10, mub0, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
<     if(t0 - t10 < minT) {
<         tbqs(minT + 1, mub0, muq0, mus0);
<     } else {
<         tbqs(t0 - t10, mub0, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
---
> double eos::dwds()
> {
> 	double dw_ds;
879,894c305,309
<     //perturb mub
<     if(mub0 + muB10 > maxMuB) {
<         tbqs(t0, maxMuB - 1, muq0, mus0);
<     } else {
<         tbqs(t0, mub0 + muB10, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
<     if(mub0 - muB10 < minMuB) {
<         tbqs(t0, minMuB + 1, muq0, mus0);
<     } else {
<         tbqs(t0, mub0 - muB10, muq0, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
---
> 	if (typerem==ideal)
> 		dw_ds=dwds_ideal();
> 	else if (typerem==table)
> 	{
> 		dw_ds=dwds_tab();
897,913c312
<     //perturn muq
<     if(muq0 + muQ10 > maxMuQ) {
<         tbqs(t0, mub0, maxMuQ - 1, mus0);
<     } else {
<         tbqs(t0, mub0, muq0 + muQ10, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
<     if(muq0 - muQ10 < minMuQ) {
<         tbqs(t0, mub0, minMuQ + 1, mus0);
<     } else {
<         tbqs(t0, mub0, muq0 - muQ10, mus0);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
---
> 	return dw_ds;
915,931c314
<     //perturb mus
<     if(mus0 + muS10 > maxMuS) {
<         tbqs(t0, mub0, muq0, maxMuS - 1);
<     } else {
<         tbqs(t0, mub0, muq0, mus0 + muS10);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
<     if(mus0 - muS10 < maxMuS) {
<         tbqs(t0, mub0, muq0, minMuS + 1);
<     } else {
<         tbqs(t0, mub0, muq0, mus0 - muS10);
<     }
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
---
> };
933,937d315
<     //check mu = 0
<     tbqs(t0, 0, 0, 0);
<     if(rootfinder4D(sin, 0, Bin, Sin, Qin, TOLERANCE, STEPS)) {
<         return entrVal;
<     }
939,941d316
<     tbqs(t0, mub0, muq0, mus0);
<     return -1;
< }
943,946d317
< double eos::s_terms_T(double Tt) { //return entropy at a given temperature for muB = muS = muQ = 0
<     tbqs(Tt, 0, 0, 0);
<     return entrVal;
< } 
947a319,333
> eos::~eos()
> {
> 	
> 	
> };
> 
> double eos::e()
> {
> 	return energy;
> };
> 
> double eos::p()
> {
> 	return pressure;
> };
949,951c335,338
< // UNCOMMENTED BY C. PLUMBERG
< void eos::eosin(std::string type) {}
< double eos::A() {return 0;}
---
> double eos::s()
> {
> 	return entropy;
> };
952a340,343
> double eos::T()
> {
> 	return temp;
> };
953a345,346
> double eos::A()
> {
955,956c348,351
< double eos::efreeze() {return 0;}
< double eos::sfreeze() {return 0;}
---
> 	if (typerem==ideal)
> 		return Aideal();
> 	else if (typerem==table)
> 		return Atable();
958a354,355
> 	return 0.;
> };
959a357,359
> double eos::Aideal()
> {
> 	Aout=energy+pressure-cp2*pow(entropy,fourthirds);
961,999c361,362
< //struct to pass the target (E, rhoB, rhoQ, rhoS) into the rootfinder function
< struct rootfinder_parameters {
<     double eorEntGiven;          //these are the desired s and BSQ
<     double rhoBGiven;
<     double rhoQGiven;
<     double rhoSGiven;
<     BSpline eorEntSpline;        //the splines that contain interpolations over s, BSQ
<     BSpline rhoBSpline;
<     BSpline rhoQSpline;
<     BSpline rhoSSpline;
<     rootfinder_parameters();
<     rootfinder_parameters(double seteorEntGiven, double setRhoBGiven, double setRhoQGiven, double setRhoSGiven, BSpline setEntrSpline, BSpline setRhoBSPLine, BSpline setRhoQSpline, BSpline setRhoSSpline);
<     public:
<         void set(double setEorEntGiven, double setRhoBGiven, double setRhoQGiven, double setRhoSGiven, BSpline setEntrSpline, BSpline setRhoBSpline, BSpline setRhoQSpline, BSpline setRhoSSpline);
< };
< //Default constructor to make the compiler happy. Should never be called
< rootfinder_parameters::rootfinder_parameters() : eorEntSpline(4), rhoBSpline(4), rhoQSpline(4), rhoSSpline(4) {}
< //constructor which initializes all struct variables
< rootfinder_parameters::rootfinder_parameters(double setEorEntGiven, double setRhoBGiven, double setRhoQGiven, double setRhoSGiven, BSpline setEorEntSpline, BSpline setRhoBSpline, BSpline setRhoQSpline, BSpline setRhoSSpline) : eorEntSpline(4), rhoBSpline(4), rhoQSpline(4), rhoSSpline(4)
< {
<     eorEntGiven = setEorEntGiven;
<     rhoBGiven = setRhoBGiven;
<     rhoQGiven = setRhoQGiven;
<     rhoSGiven = setRhoSGiven;
<     eorEntSpline = setEorEntSpline;
<     rhoBSpline = setRhoBSpline;
<     rhoQSpline = setRhoQSpline;
<     rhoSSpline = setRhoSSpline;
< }
< void rootfinder_parameters::set(double setEorEntGiven, double setRhoBGiven, double setRhoQGiven, double setRhoSGiven, BSpline setEorEntSpline, BSpline setRhoBSpline, BSpline setRhoQSpline, BSpline setRhoSSpline) {
<     eorEntGiven = setEorEntGiven;
<     rhoBGiven = setRhoBGiven;
<     rhoQGiven = setRhoQGiven;
<     rhoSGiven = setRhoSGiven;
<     eorEntSpline = setEorEntSpline;
<     rhoBSpline = setRhoBSpline;
<     rhoQSpline = setRhoQSpline;
<     rhoSSpline = setRhoSSpline;
< }
---
> 	return Aout;
> };
1001,1027d363
< //helper function for the rootfinder. It provides the correct difference of s, rhoB, rhoQ, rhoS at a given (T, muB, muQ, muS) from the target
< //used when rootfinder is given an entropy, baryon density, charge density, strangeness density
< //x = (T, muB, muQ, muS), params = (sGiven, rhoBGiven, rhoQGiven, rhoSGiven), f becomes (s - sGiven, rhoB - rhoBGiven, rhoQ - rhoQGiven, rhoS - rhoSGiven)
< int rootfinder_fsbqs(const gsl_vector *x, void *params, gsl_vector *f);
< int rootfinder_fsbqs(const gsl_vector *x, void *params, gsl_vector *f) {
<     //x contains the next (T, muB, muS) coordinate to test
<     DenseVector tbqsToEval(4);
<     tbqsToEval(0) = gsl_vector_get(x,0);
<     tbqsToEval(1) = gsl_vector_get(x,1);      //convert x into densevector so it can be a BSpline evaluation point
<     tbqsToEval(2) = gsl_vector_get(x,2);
<     tbqsToEval(3) = gsl_vector_get(x,3);
< 
< 
<     double entrGiven, rhoBGiven, rhoQGiven, rhoSGiven, entr, rhoB, rhoQ, rhoS;
<     entrGiven = ((rootfinder_parameters*)params)->eorEntGiven;
<     rhoBGiven = ((rootfinder_parameters*)params)->rhoBGiven;            //given variables contain the target point
<     rhoQGiven = ((rootfinder_parameters*)params)->rhoQGiven;
<     rhoSGiven = ((rootfinder_parameters*)params)->rhoSGiven;
<     entr = (((rootfinder_parameters*)params)->eorEntSpline).eval(tbqsToEval);    //s, rhoB, rhoQ, rhoS contain the current point
<     rhoB = (((rootfinder_parameters*)params)->rhoBSpline).eval(tbqsToEval);
<     rhoQ = (((rootfinder_parameters*)params)->rhoQSpline).eval(tbqsToEval);
<     rhoS = (((rootfinder_parameters*)params)->rhoSSpline).eval(tbqsToEval);
< 
<     gsl_vector_set(f, 0, (entr - entrGiven)); //f[0] contains (s(T,muB,muQ,muS) - sGiven)
<     gsl_vector_set(f, 1, (rhoB - rhoBGiven)); //f[1] contains (rhoB(T,muB,muQ,muS) - rhoBGiven)
<     gsl_vector_set(f, 2, (rhoQ - rhoQGiven)); //f[2] contains (rhoQ(T,muB,muQ,muS) - rhoQGiven)
<     gsl_vector_set(f, 3, (rhoS - rhoSGiven)); //f[2] contains (rhoS(T,muB,muQ,muS) - rhoSGiven)
1029,1030d364
<     return GSL_SUCCESS;
< }
1032,1057c366,368
< //helper function for the rootfinder. It provides the correct difference of E and rhoB at a given (T, muB, muQ, muS) from the target
< //used when rootfinder is given an energy density and a baryon density
< //x = (T, muB, muQ, muS), params = ((eGiven, rhoBGiven, rhoQGiven, rhoSGiven), f becomes (e - eGiven, rhoB - rhoBGiven, rhoQ - rhoQGiven, rhoS - rhoSGiven)
< int rootfinder_febqs(const gsl_vector *x, void *params, gsl_vector *f);
< int rootfinder_febqs(const gsl_vector *x, void *params, gsl_vector *f) {
<     //x contains the next (T, muB, muQ, muS) coordinate to test
<     DenseVector tbqsToEval(4);
<     tbqsToEval(0) = gsl_vector_get(x,0);
<     tbqsToEval(1) = gsl_vector_get(x,1);      //convert x into densevector so it can be a BSpline evaluation point
<     tbqsToEval(2) = gsl_vector_get(x,2);
<     tbqsToEval(3) = gsl_vector_get(x,3);
< 
<     double eGiven, rhoBGiven, rhoQGiven, rhoSGiven, e, rhoB, rhoQ, rhoS;
<     eGiven = ((rootfinder_parameters*)params)->eorEntGiven;
<     rhoBGiven = ((rootfinder_parameters*)params)->rhoBGiven;            //given variables contain the target point
<     rhoQGiven = ((rootfinder_parameters*)params)->rhoQGiven;
<     rhoSGiven = ((rootfinder_parameters*)params)->rhoSGiven;
<     e = (((rootfinder_parameters*)params)->eorEntSpline).eval(tbqsToEval);    //e, rhoB, rhoQ, rhoS contain the current point
<     rhoB = (((rootfinder_parameters*)params)->rhoBSpline).eval(tbqsToEval);
<     rhoQ = (((rootfinder_parameters*)params)->rhoQSpline).eval(tbqsToEval);
<     rhoS = (((rootfinder_parameters*)params)->rhoSSpline).eval(tbqsToEval);
< 
<     gsl_vector_set(f, 0, (e - eGiven)); //f[0] contains (e(T,muB,muQ,muS) - eGiven)
<     gsl_vector_set(f, 1, (rhoB - rhoBGiven)); //f[1] contains the (rhoB(T,muB,muQ,muS) - rhoBGiven)
<     gsl_vector_set(f, 2, (rhoQ - rhoQGiven)); //f[2] contains the (rhoQ(T,muB,muQ,muS) - rhoQGiven)
<     gsl_vector_set(f, 3, (rhoS - rhoSGiven)); //f[2] contains the (rho2(T,muB,muQ,muS) - rhoSGiven)
---
> void eos::update_s(double s_in)
> {
> 	entropy=s_in;
1059,1060d369
<     return GSL_SUCCESS;
< }
1061a371,372
> 	if (typerem==ideal)
> 	{
1062a374,376
> 		pressure_ideal();	
> 		energy_ideal();
> 		temp_ideal();
1064c378,380
< bool eos::rootfinder4D(double entrGiven, double eGiven, double rhoBGiven, double rhoSGiven, double rhoQGiven, double error, size_t steps) {
---
> 	}
> 	else if (typerem==table)
> 	{
1066,1071c382,383
<     //declare x = (T, muB, muS)
<     gsl_vector *x = gsl_vector_alloc(4);
<     gsl_vector_set(x, 0, T());
<     gsl_vector_set(x, 1, muB());
<     gsl_vector_set(x, 2, muQ());
<     gsl_vector_set(x, 3, muS());
---
> 		if (s_in<scheck)
> 		{
1073,1076c385
<     //initialize the rootfinder equation to the correct variable quantities
<     bool isEntropy = false;
<     if(eGiven == 0) {
<         isEntropy = true;
---
> 			tablow();
1078,1082c387,393
<     rootfinder_parameters p;
<     if(isEntropy) {
<         p.set(entrGiven, rhoBGiven, rhoQGiven, rhoSGiven, entrSpline, bSpline, qSpline, sSpline);
<         } else {
<         p.set(eGiven, rhoBGiven, rhoQGiven, rhoSGiven, eSpline, bSpline, qSpline, sSpline);
---
> 		else
> 		{
> 		
> 		
> 		temp_tab();
> 		pressure_tab();
> 		energy_tab();
1085,1091d395
<     //initialize multiroot solver
<     gsl_multiroot_fsolver *solver;
<     gsl_multiroot_function f;
<     if(isEntropy) {
<         f.f = &rootfinder_fsbqs;
<     } else {
<         f.f = &rootfinder_febqs;
1093,1094c397,399
<     f.n = 4;
<     f.params = &p;
---
> 	epp();
> 	
> };
1096,1097c401,403
<     solver = gsl_multiroot_fsolver_alloc(TYPE, 4);
<     gsl_multiroot_fsolver_set(solver, &f, x);
---
> void eos::tablow()
> {
> 	temp=spline(r8_slow,y_Tlow,entropy,pos);
1099,1100c405,406
<     int status;
<     size_t iter = 0;
---
> 	pressure =splinepos(y_Tlow,y_plow,temp,pos);	
>   	energy = splinepos(y_Tlow,y_elow,temp,pos);
1102,1104c408
<     do {
<         ++iter;
<         status = gsl_multiroot_fsolver_iterate(solver);
---
> };
1106,1107c410,439
<         if(status) {
<             return 0;      //break if the rootfinder gets stuck
---
> 
> double eos::dervs(double (eos::*f)(double) ,double x, double h,double & err)
> {
>  double out, con=1.4, con2=pow(con,2.), safe=2.;
>  double errt, fac,hh, a[NTAB][NTAB];
>  
>  if (h==0.)
>  {
>  	cout << "Error: In double dervs - h must be nonzero" << endl;
>  	exit(1);
>  }
>  hh=h; 
>  a[0][0]=((this->*f)(x+hh)-(this->*f)(x-hh))/(2.*hh);
>  err=BIG;
>  
>  for(int i=1;i<NTAB;i++)
>  {
>  	hh=hh/con;
>  	a[0][i]=((this->*f)(x+hh)-(this->*f)(x-hh))/(2.*hh);
>  	fac=con2;
>  	
>  	for (int j=1;j<=i;j++)
>  	{
>  		a[j][i]=(a[j-1][i]*fac-a[j-1][i-1])/(fac-1.);
>  		fac=con2*fac;
>  		errt=max(abs(a[j][i]-a[j-1][i]),abs(a[j][i]-a[j-1][i-1]));
>  		if (errt<=err)
>  		{
>  			err=errt;
>  			out=a[j][i];
1109,1124d440
<         if(gsl_vector_get(solver->x, 0) < minT) {
<             return 0;
<         } else if(gsl_vector_get(solver->x, 0) > maxT) {
<             return 0;
<         } else if (gsl_vector_get(solver->x, 1) < minMuB) {
<             return 0;
<         } else if (gsl_vector_get(solver->x, 1) > maxMuB) {
<             return 0;
<         } else if (gsl_vector_get(solver->x, 2) < minMuQ) {     //break if the rootfinder goes out of bounds
<             return 0;
<         } else if (gsl_vector_get(solver->x, 2) > maxMuQ) {
<             return 0;
<         } else if (gsl_vector_get(solver->x, 3) < minMuS) {
<             return 0;
<         } else if (gsl_vector_get(solver->x, 3) > maxMuS) {
<             return 0;
1125a442,444
>  	if (abs(a[i][i]-a[i-1][i-1])>=(safe*err)) return out;
>  }
>  return out;
1127c446
<         status = gsl_multiroot_test_residual(solver->f, error);
---
> };
1129c448,449
<     } while (status == GSL_CONTINUE && iter < steps);
---
> double eos::dervsprint(double (eos::*f)(double) ,double x, double h,double & err)
> {
1130a451,452
>  double out, con=1.4, con2=pow(con,2.), safe=2.;
>  double errt, fac,hh, a[NTAB][NTAB];
1132,1134c454,478
<     bool found = true; //to return variable
<     if(iter >= steps) {
<         found = false;
---
>  if (h==0.)
>  {
>  	cout << "Error: In double dervs - h must be nonzero" << endl;
>  	exit(1);
>  }
>  hh=h/2; 
>  a[0][0]=((this->*f)(x+hh)-(this->*f)(x-hh))/(2.*hh);
>  err=BIG;
>  
>  for(int i=1;i<NTAB;i++)
>  {
>  	hh=hh/con;
>  	a[0][i]=((this->*f)(x+hh)-(this->*f)(x-hh))/(2.*hh);
>  	fac=con2;
>  	
>  	for (int j=1;j<=i;j++)
>  	{
>  		a[j][i]=(a[j-1][i]*fac-a[j-1][i-1])/(fac-1.);
>  		fac=con2*fac;
>  		errt=max(abs(a[j][i]-a[j-1][i]),abs(a[j][i]-a[j-1][i-1]));
>  		cout << i << " " << j << " " << a[0][i] << " " << a[j][i] << " " << err << endl;
>  		if (errt<=err)
>  		{
>  			err=errt;
>  			out=a[j][i];
1135a480,483
>  	}
>  	if (abs(a[i][i]-a[i-1][i-1])>=(safe*err)) return out;
>  }
>  return out;
1136a485
> };
1138,1140d486
<     if(found) {
<         tbqs(gsl_vector_get(solver->x, 0), gsl_vector_get(solver->x, 1), gsl_vector_get(solver->x, 2), gsl_vector_get(solver->x, 3));    //set T, muB, muQ, muS
<     }
1142,1146c488,491
<     //memory deallocation
<     gsl_multiroot_fsolver_free(solver);
<     gsl_vector_free(x);
<     return found;
< }
---
> double eos::h_calc(double x)
> {
> 	double ef;
> 	ef=DBL_EPSILON;
1147a493
> 	if (x==0.) return 0.0001*pow(DBL_EPSILON,onethird);
1148a495
>  	return pow(ef,onethird)*x;
1149a497
> };
1150a499,501
> double eos::e_plow(double s)
> {
> 	double e_sub,p_sub;
1152a504,505
> 	e_sub = spline(r8_slow,y_elow,s,pos);
> 	p_sub = splinepos(y_slow,y_plow,s,pos);
1154,1198d506
< //struct to pass the target quantities into the rootfinder function
< struct quant_rootfinder_parameters {
<     double tGiven;
<     double muBGiven;
<     double muQGiven;
<     double muSGiven;
<     double quantGiven;          //the value we are looking for in the desired quantity
<     int whichIndep;
<     BSpline pSpline;        //the spine of the correct quantity
<     BSpline entrSpline;
<     BSpline eSpline;
<     string quantity;
<     quant_rootfinder_parameters();
<     quant_rootfinder_parameters(string setQuantity, int setWhichIndep, double setQuantGiven, double setT, double setmuB, double setmuQ, double setmuS, BSpline setPSpline, BSpline setEntrSpline, BSpline setESpline);
<     public:
<         void set(string setQuantity, int setWhichIndep, double setQuantGiven, double setT, double setmuB, double setmuQ, double setmuS, BSpline setPSpline, BSpline setEntrSpline, BSpline setESpline);
< };
< //Default constructor
< quant_rootfinder_parameters::quant_rootfinder_parameters() : pSpline(4), entrSpline(4), eSpline(4) {}
< //constructor which initializes all struct variables
< quant_rootfinder_parameters::quant_rootfinder_parameters(string setQuantity, int setWhichIndep, double setQuantGiven, double setT, double setmuB, double setmuQ, double setmuS, BSpline setPSpline, BSpline setEntrSpline, BSpline setESpline) : pSpline(4), entrSpline(4), eSpline(4)
< {
<     whichIndep = setWhichIndep;
<     quantity = setQuantity;
<     quantGiven = setQuantGiven;
<     pSpline = setPSpline;
<     entrSpline = setEntrSpline;
<     eSpline = setESpline;
<     tGiven = setT;
<     muBGiven = setmuB;
<     muQGiven = setmuQ;
<     muSGiven = setmuS;
< }
< void quant_rootfinder_parameters::set(string setQuantity, int setWhichIndep, double setQuantGiven, double setT, double setmuB, double setmuQ, double setmuS, BSpline setPSpline, BSpline setEntrSpline, BSpline setESpline) {
<     whichIndep = setWhichIndep;
<     quantity = setQuantity;
<     quantGiven = setQuantGiven;
<     pSpline = setPSpline;
<     entrSpline = setEntrSpline;
<     eSpline = setESpline;
<     tGiven = setT;
<     muBGiven = setmuB;
<     muQGiven = setmuQ;
<     muSGiven = setmuS;
< }
1200,1226c508,509
< //helper function for the rootfinder. It provides the correct difference of quantity from the target
< int quant_rootfinder_f(const gsl_vector *x, void *params, gsl_vector *f);
< int quant_rootfinder_f(const gsl_vector *x, void *params, gsl_vector *f) {
<     int whichIndep = ((quant_rootfinder_parameters*)params)->whichIndep;
<     //x contains the next (T, muB, muS) coordinate to test
<     DenseVector tbqsToEval(4);
<     if(whichIndep == 1) {
<         tbqsToEval(0) = gsl_vector_get(x,0);
<         tbqsToEval(1) = ((quant_rootfinder_parameters*)params)->muBGiven;      //convert x into densevector so it can be a BSpline evaluation point
<         tbqsToEval(2) = ((quant_rootfinder_parameters*)params)->muQGiven;
<         tbqsToEval(3) = ((quant_rootfinder_parameters*)params)->muSGiven;
<     } else if(whichIndep == 2) {
<         tbqsToEval(0) = ((quant_rootfinder_parameters*)params)->tGiven;
<         tbqsToEval(1) = gsl_vector_get(x,0);      //convert x into densevector so it can be a BSpline evaluation point
<         tbqsToEval(2) = ((quant_rootfinder_parameters*)params)->muQGiven;
<         tbqsToEval(3) = ((quant_rootfinder_parameters*)params)->muSGiven;
<     } else if(whichIndep == 3) {
<         tbqsToEval(0) = ((quant_rootfinder_parameters*)params)->tGiven;
<         tbqsToEval(1) = ((quant_rootfinder_parameters*)params)->muBGiven;      //convert x into densevector so it can be a BSpline evaluation point
<         tbqsToEval(2) = gsl_vector_get(x,0);
<         tbqsToEval(3) = ((quant_rootfinder_parameters*)params)->muSGiven;
<     } else {
<         tbqsToEval(0) = ((quant_rootfinder_parameters*)params)->tGiven;
<         tbqsToEval(1) = ((quant_rootfinder_parameters*)params)->muBGiven;      //convert x into densevector so it can be a BSpline evaluation point
<         tbqsToEval(2) = ((quant_rootfinder_parameters*)params)->muQGiven;
<         tbqsToEval(3) = gsl_vector_get(x,0);
<     }
---
> 	return e_sub+p_sub;
> };
1227a511,513
> double eos::e_ptable(double s)
> {
> 	double e_sub,p_sub;
1230,1245c516,517
<     double quantGiven, quant;
<     if(((quant_rootfinder_parameters*)params)->quantity == "e") {
<         quantGiven = ((quant_rootfinder_parameters*)params)->quantGiven;
<         quant = (((quant_rootfinder_parameters*)params)->eSpline).eval(tbqsToEval);
<     } else if(((quant_rootfinder_parameters*)params)->quantity == "p") {
<         quantGiven = ((quant_rootfinder_parameters*)params)->quantGiven;
<         quant = (((quant_rootfinder_parameters*)params)->pSpline).eval(tbqsToEval);
<     } else if(((quant_rootfinder_parameters*)params)->quantity == "entr") {
<         quantGiven = ((quant_rootfinder_parameters*)params)->quantGiven;
<         quant = (((quant_rootfinder_parameters*)params)->entrSpline).eval(tbqsToEval);
<     } else if(((quant_rootfinder_parameters*)params)->quantity == "gibbs") {
<         quantGiven = ((quant_rootfinder_parameters*)params)->quantGiven;
<         quant = (((quant_rootfinder_parameters*)params)->eSpline).eval(tbqsToEval);
<         quant += (((quant_rootfinder_parameters*)params)->pSpline).eval(tbqsToEval);
<         quant -= ((((quant_rootfinder_parameters*)params)->entrSpline).eval(tbqsToEval))*tbqsToEval(0);
<     }
---
> 	e_sub = spline(r8_s,y_e,s,pos);
> 	p_sub = splinepos(y_s,y_p,s,pos);
1247d518
<     gsl_vector_set(f, 0, (quant - quantGiven));
1249,1250c520,521
<     return GSL_SUCCESS;
< }
---
> 	return e_sub+p_sub;
> };
1252c523
< bool eos::quant_rootfinder4D(double quantGiven, string quantType, int whichIndep, double error, size_t steps) {
---
> #endif
1254,1344d524
<     //declare x = T
<     gsl_vector *x = gsl_vector_alloc(1);
<     quant_rootfinder_parameters p;
<     if(whichIndep == 1) {
<         gsl_vector_set(x, 0, T());
<     } else if(whichIndep == 2) {
<         gsl_vector_set(x, 0, muB());
<     } else if(whichIndep == 3) {
<         gsl_vector_set(x, 0, muQ());
<     } else if(whichIndep == 4) {
<         gsl_vector_set(x, 0, muS());
<     } else {
<         std::cout << "Please select a gridded quantity to vary during search" << std::endl;
<         std::cout << "t = 1,  muB = 2,  muQ = 3,  muS = 4" << std::endl;
<         return 0;
<     }
<     p.set(quantType, whichIndep, quantGiven, T(), muB(), muQ(), muS(), pSpline, entrSpline, eSpline);
< 
<     //initialize multiroot solver
<     const gsl_multiroot_fsolver_type *type;
<     gsl_multiroot_fsolver *solver;
<     gsl_multiroot_function f;
<     f.f = &quant_rootfinder_f;
<     f.n = 1;
<     f.params = &p;
< 
<     //type options: dnewton, hybrids, hybrid, broyden
<     //the dnewton and broyden methods crash the program with a bad guess. Hybrid and hybrids do not
<     //dnewton works the fastest on guesses that it can successfully reach. Hybrids is faster than hybrid
<     //I am choosing hybrids because it is the most accurate. Hybrids is slower than dnewton, but more reliable
<     type = gsl_multiroot_fsolver_hybrids;
<     solver = gsl_multiroot_fsolver_alloc(type, 1);
<     gsl_multiroot_fsolver_set(solver, &f, x);
< 
<     int status;
<     size_t iter = 0;
< 
<     do {
<         ++iter;
<         status = gsl_multiroot_fsolver_iterate(solver);
< 
<         if(status) {
<             return 0;      //break if the rootfinder gets stuck
<         }
<         if(whichIndep == 1) {
<             if(gsl_vector_get(solver->x, 0) < minT) {
<                 return 0;
<             } else if(gsl_vector_get(solver->x, 0) > maxT) {
<                 return 0;
<             }
<         } else if(whichIndep == 2) {
<             if(gsl_vector_get(solver->x, 0) < minMuB) {
<                 return 0;
<             } else if(gsl_vector_get(solver->x, 0) > maxMuB) {
<                 return 0;
<             }
<         } else if(whichIndep == 3) {
<             if(gsl_vector_get(solver->x, 0) < minMuQ) {
<                 return 0;
<             } else if(gsl_vector_get(solver->x, 0) > maxMuQ) {
<                 return 0;
<             }
<         } else if(whichIndep == 4) {
<             if(gsl_vector_get(solver->x, 0) < minMuS) {
<                 return 0;
<             } else if(gsl_vector_get(solver->x, 0) > maxMuS) {
<                 return 0;
<             }
<         }
<         
< 
<         status = gsl_multiroot_test_residual(solver->f, error);
<     
<     } while (status == GSL_CONTINUE && iter < steps);
< 
< 
<     bool found = true; //to return variable
<     if(iter >= steps) {
<         found = false;
<     }
< 
<     
<     if(found) {
<         tbqs(gsl_vector_get(solver->x, 0), muB(), muQ(), muS());    //set T, muB, muQ, muS
<     }
< 
<     //memory deallocation
<     gsl_multiroot_fsolver_free(solver);
<     gsl_vector_free(x);
<     return found;
< }
