//Perform a few tests to ensure that the EoS will be interpolated correctly
#include <memory>
#include <filesystem>

#include "H5Cpp.h"
#include <omp.h>

#include <Cabana_Core.hpp>

#include "particle.h"
#include "eos.h"
#include "settings.h"
#include "system_state.h"
#include "thermodynamic_info.h"
#include "eos_interpolator.h"
#include "stopwatch.h"

#define TOL 1.E-7

int check_args(int argc, char** argv){
  //Usage: ./generate_eos_table <nthreads> <eos_type> <eos_path>
  if (argc != 4){
    std::cerr << "Usage: " << argv[0] <<
    " <nthreads> <eos_type> <eos_path>" << std::endl;
    std::cerr << "nthreads: number of threads to use" << std::endl;
    std::cerr << "eos_type: 'table', 'tanh_conformal', 'conformal' or 'conformal_diagonal'" << std::endl;
    std::cerr << "eos_path: path to EoS table" << std::endl;
    return 1;
  } else {
    std::cout << "Number of threads: " << argv[1] << std::endl;
    std::cout << "EoS type.........: " << argv[2] << std::endl;
    std::cout << "EoS path.........: " << argv[3] << std::endl;
    return 0;
  }
}

/// @brief Evaluates the EoS at the grid points and checks that the
/// interpolation is correct
/// @param file_path path to the EoS table generated by generate_eos_table
/// @param eos_type type of EoS to use
/// @param nthreads number of threads to use
void test1(std::string file_path, std::string eos_type, int nthreads){

    ccake::EoS_Interpolator eos_interpolator(file_path);
    ccake::EquationOfState eos[nthreads];

    std::shared_ptr<Settings> settings = std::make_shared<Settings>();

    //Setup EoS
    settings->eos_type = eos_type;
    if (settings->eos_type == "table"){
        settings->eos_path = "EoS/Houston/thermo.h5";
    }

    //Cannot be initialized in parallel to avoid simultaneous access to HDF5 file
    for(int i=0; i<nthreads; ++i){
      eos[i].set_SettingsPtr(settings);
      eos[i].init();
    }

    std::shared_ptr<ccake::SystemState<1>> systemPtr
        = std::make_shared<ccake::SystemState<1>>(settings);

    //==========================================================================
    // Open the HDF5 file and retrieve the grid points
    //==========================================================================
    H5::H5File file(file_path, H5F_ACC_RDONLY);
    H5::Attribute s_min_attr = file.openAttribute("s_min");
    H5::Attribute s_max_attr = file.openAttribute("s_max");
    H5::Attribute ds_attr = file.openAttribute("ds");
    H5::Attribute rhoB_min_attr = file.openAttribute("rhoB_min");
    H5::Attribute rhoB_max_attr = file.openAttribute("rhoB_max");
    H5::Attribute dB_attr = file.openAttribute("drhoB");
    H5::Attribute rhoQ_min_attr = file.openAttribute("rhoQ_min");
    H5::Attribute rhoQ_max_attr = file.openAttribute("rhoQ_max");
    H5::Attribute dQ_attr = file.openAttribute("drhoQ");
    H5::Attribute rhoS_min_attr = file.openAttribute("rhoS_min");
    H5::Attribute rhoS_max_attr = file.openAttribute("rhoS_max");
    H5::Attribute dS_attr = file.openAttribute("drhoS");

    double s_min, s_max, B_min, B_max, Q_min, Q_max, S_min, S_max,
            ds, dB, dQ, dS;
    s_min_attr.read(H5::PredType::NATIVE_DOUBLE, &s_min);
    s_max_attr.read(H5::PredType::NATIVE_DOUBLE, &s_max);
    ds_attr.read(H5::PredType::NATIVE_DOUBLE, &ds);
    rhoB_min_attr.read(H5::PredType::NATIVE_DOUBLE, &B_min);
    rhoB_max_attr.read(H5::PredType::NATIVE_DOUBLE, &B_max);
    dB_attr.read(H5::PredType::NATIVE_DOUBLE, &dB);
    rhoQ_min_attr.read(H5::PredType::NATIVE_DOUBLE, &Q_min);
    rhoQ_max_attr.read(H5::PredType::NATIVE_DOUBLE, &Q_max);
    dQ_attr.read(H5::PredType::NATIVE_DOUBLE, &dQ);
    rhoS_min_attr.read(H5::PredType::NATIVE_DOUBLE, &S_min);
    rhoS_max_attr.read(H5::PredType::NATIVE_DOUBLE, &S_max);
    dS_attr.read(H5::PredType::NATIVE_DOUBLE, &dS);

    int Ns = std::round((s_max - s_min)/ds+1);
    int NB = std::round((B_max - B_min)/dB+1);
    int NS = std::round((S_max - S_min)/dS+1);
    int NQ = std::round((Q_max - Q_min)/dQ+1);


    //==========================================================================
    // We use a fake particle system to evaluate the EoS at the grid points
    // using the EoS interpolator
    //==========================================================================

    systemPtr->n_particles = Ns*NB*NQ*NS;
    const long N = Ns*NB*NQ*NS;
    cout << "Allocating fake particle system with "
        << systemPtr->n_particles << " particles."<< endl;
    systemPtr->t = 2.;
    for (int is=0; is<Ns;++is)
    for (int iB=0; iB<NB;++iB)
    for (int iQ=0; iQ<NQ;++iQ)
    for (int iS=0; iS<NS;++iS){
      ccake::Particle<1> particle;
      systemPtr->particles.push_back(particle);
    }

    settings->xmin = -4;
    settings->ymin = -6;
    settings->etamin = -2;
    settings->hT = 1;
    settings->using_shear = true;
    settings->t0 = 2;
    systemPtr->initialize();

    int idx = 0;
    for (int is=0; is<Ns;++is)
    for (int iB=0; iB<NB;++iB)
    for (int iS=0; iS<NS;++iS)
    for (int iQ=0; iQ<NQ;++iQ)
    {
      ccake::Particle<1>* p = &systemPtr->particles[idx];
      p->ID = idx;
      p->thermo.s = s_min+is*ds;
      p->thermo.rhoB = B_min + iB*dB;
      p->thermo.rhoS = S_min + iS*dS;
      p->thermo.rhoQ = Q_min + iQ*dQ;
      idx++;
    }

    cout << "Evaluating EoS at grid points" << endl;
    systemPtr->allocate_cabana_particles();
    eos_interpolator.fill_thermodynamics(systemPtr->cabana_particles, 0.0);
    systemPtr->copy_device_to_host();
    cout << "EoS evaluation finished." << endl;


    //==========================================================================
    // Check that the EoS is correctly interpolated at the grid points using
    // the original EoS inverter
    //==========================================================================

    //Get start time
    std::chrono::time_point<std::chrono::system_clock> start, end;
    start = std::chrono::system_clock::now();

    int idx_a[nthreads]; for(int i=0; i<nthreads; ++i) idx_a[i]=0;
    cout << "Testing EoS interpolation at grid points" << endl;
    #pragma omp parallel for collapse(4) schedule(dynamic)
    for (int is=0; is<Ns;++is)
    for (int iB=0; iB<NB;++iB)
    for (int iQ=0; iQ<NQ;++iQ)
    for (int iS=0; iS<NS;++iS)
    {

      int idx = is*NB*NQ*NS + iB*NQ*NS + iS*NQ + iQ;
      int ith = omp_get_thread_num();
      eos[ith].tbqs(800./197., .0, .0, .0, "default");
      double s_In = s_min + is*ds;
      double rhoB_In = B_min + iB*dB;
      double rhoQ_In = Q_min + iQ*dQ;
      double rhoS_In = S_min + iS*dS;
      bool update_s_success = eos[ith].update_s(s_In, rhoB_In, rhoS_In, rhoQ_In, false);

      ccake::thermodynamic_info thermo;
      if ( update_s_success ) eos[ith].set_thermo( thermo );
      //Check that the EoS is correctly interpolated
      if ( std::abs(thermo.T - systemPtr->particles[idx].thermo.T ) > TOL ){
        #pragma omp critical
        {
        std::cerr << "EoS interpolation failed at point = " << idx << std::endl;
        std::cerr << "s_rootfinder      = " << std::setprecision(13) << thermo.s << " "
                  << "s_interpolator    = " << std::setprecision(13) << systemPtr->particles[idx].thermo.s << " "
                  << "s_In              = " << std::setprecision(13) << s_In << " " << endl;
        std::cerr << "rhoB_rootfinder   = " << std::setprecision(13) << thermo.rhoB << " "
                  << "rhoB_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoB << " "
                  << "rhoB_In           = " << std::setprecision(13) << rhoB_In << " " << endl;
        std::cerr << "rhoS_rootfinder   = " << std::setprecision(13) << thermo.rhoS << " "
                    << "rhoS_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoS << " "
                    << "rhoS_In           = " << std::setprecision(13) << rhoS_In << " " << endl;
        std::cerr << "rhoQ_rootfinder   = " << std::setprecision(13) << thermo.rhoQ << " "
                  << "rhoQ_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoQ << " "
                  << "rhoQ_In           = " << std::setprecision(13) << rhoQ_In << " " << endl;
        std::cerr << "T_rootfinder      = " << std::setprecision(13) << thermo.T*197 << " " << endl;
        std::cerr << "T_interpolator    = " << std::setprecision(13) << systemPtr->particles[idx].thermo.T*197 << " " << endl;
        abort();
       }
    }
      //Get end time
      if(ith==0 && idx_a[0]%100==0){
        #pragma omp critical
        {
          int idx_s=0;
          for (int i=1; i<nthreads; ++i) idx_s += idx_a[i];
          end = std::chrono::system_clock::now();
          std::chrono::duration<double> elapsed_seconds = end-start;
          std::cout << "Test 1 progress: " << (double)idx_s/N*100. << "% done. Elapsed time: " << elapsed_seconds.count() << "s";
          std::cout << " Estimated time remaining: " << elapsed_seconds.count()/(double)idx_s*(N-idx_s) << "s" << std::endl;
        }
      }
      idx_a[ith]++;
    }
    cout << "Test 1 passed" << endl;
}

/// @brief Evaluates the EoS at random points and checks that the
/// interpolation has the expected accuracy
/// @param file_path path to the EoS table generated by generate_eos_table
/// @param eos_type type of EoS to use
/// @param nthreads number of threads to use
void test2(std::string file_path, std::string eos_type, int nthreads){

    ccake::EoS_Interpolator eos_interpolator(file_path);
    ccake::EquationOfState eos[nthreads];

    std::shared_ptr<Settings> settings = std::make_shared<Settings>();

    //Setup EoS
    settings->eos_type = eos_type;
    if (settings->eos_type == "table"){
        settings->eos_path = "EoS/Houston/thermo.h5";
    }

    //Cannot be initialized in parallel to avoid simultaneous access to HDF5 file
    for(int i=0; i<nthreads; ++i){
      eos[i].set_SettingsPtr(settings);
      eos[i].init();
    }

    std::shared_ptr<ccake::SystemState<1>> systemPtr
        = std::make_shared<ccake::SystemState<1>>(settings);

    //==========================================================================
    // Open the HDF5 file and retrieve the grid points
    //==========================================================================
    H5::H5File file(file_path, H5F_ACC_RDONLY);
    H5::Attribute s_min_attr = file.openAttribute("s_min");
    H5::Attribute s_max_attr = file.openAttribute("s_max");
    H5::Attribute ds_attr = file.openAttribute("ds");
    H5::Attribute rhoB_min_attr = file.openAttribute("rhoB_min");
    H5::Attribute rhoB_max_attr = file.openAttribute("rhoB_max");
    H5::Attribute dB_attr = file.openAttribute("drhoB");
    H5::Attribute rhoQ_min_attr = file.openAttribute("rhoQ_min");
    H5::Attribute rhoQ_max_attr = file.openAttribute("rhoQ_max");
    H5::Attribute dQ_attr = file.openAttribute("drhoQ");
    H5::Attribute rhoS_min_attr = file.openAttribute("rhoS_min");
    H5::Attribute rhoS_max_attr = file.openAttribute("rhoS_max");
    H5::Attribute dS_attr = file.openAttribute("drhoS");

    double s_min, s_max, B_min, B_max, Q_min, Q_max, S_min, S_max,
            ds, dB, dQ, dS;
    s_min_attr.read(H5::PredType::NATIVE_DOUBLE, &s_min);
    s_max_attr.read(H5::PredType::NATIVE_DOUBLE, &s_max);
    ds_attr.read(H5::PredType::NATIVE_DOUBLE, &ds);
    rhoB_min_attr.read(H5::PredType::NATIVE_DOUBLE, &B_min);
    rhoB_max_attr.read(H5::PredType::NATIVE_DOUBLE, &B_max);
    dB_attr.read(H5::PredType::NATIVE_DOUBLE, &dB);
    rhoQ_min_attr.read(H5::PredType::NATIVE_DOUBLE, &Q_min);
    rhoQ_max_attr.read(H5::PredType::NATIVE_DOUBLE, &Q_max);
    dQ_attr.read(H5::PredType::NATIVE_DOUBLE, &dQ);
    rhoS_min_attr.read(H5::PredType::NATIVE_DOUBLE, &S_min);
    rhoS_max_attr.read(H5::PredType::NATIVE_DOUBLE, &S_max);
    dS_attr.read(H5::PredType::NATIVE_DOUBLE, &dS);

    int Ns = std::round((s_max - s_min)/ds+1);
    int NB = std::round((B_max - B_min)/dB+1);
    int NS = std::round((S_max - S_min)/dS+1);
    int NQ = std::round((Q_max - Q_min)/dQ+1);


    //==========================================================================
    // We use a fake particle system to evaluate the EoS at the grid points
    // using the EoS interpolator
    //==========================================================================

    const int N = 100000;
    systemPtr->n_particles = N;
    cout << "Allocating fake particle system with "
        << systemPtr->n_particles << " particles."<< endl;
    systemPtr->t = 2.;
    for (int i=0; i<N;++i)
    {
      ccake::Particle<1> particle;
      systemPtr->particles.push_back(particle);
    }

    settings->xmin = -4;
    settings->ymin = -6;
    settings->etamin = -2;
    settings->hT = 1;
    settings->using_shear = true;
    settings->t0 = 2;
    systemPtr->initialize();

    //Set seed for reproducibility
    srand(42);
    int idx = 0;
    for (int i=0; i<N;++i)
    {
      ccake::Particle<1>* p = &systemPtr->particles[idx];
      p->ID = idx;
      p->thermo.s = (double)rand()/RAND_MAX*(s_max-s_min)+s_min;
      p->thermo.rhoB = (double)rand()/RAND_MAX*(B_max-B_min)+B_min;
      p->thermo.rhoS = (double)rand()/RAND_MAX*(S_max-S_min)+S_min;
      p->thermo.rhoQ = (double)rand()/RAND_MAX*(Q_max-Q_min)+Q_min;
      idx++;
    }

    cout << "Evaluating EoS at grid points" << endl;
    systemPtr->allocate_cabana_particles();
    eos_interpolator.fill_thermodynamics(systemPtr->cabana_particles, 0.0);
    systemPtr->copy_device_to_host();
    cout << "EoS evaluation finished." << endl;


    //==========================================================================
    // Check that the EoS is correctly interpolated at the grid points using
    // the original EoS inverter
    //==========================================================================

    //Get start time
    std::chrono::time_point<std::chrono::system_clock> start, end;
    start = std::chrono::system_clock::now();

    int idx_a[nthreads]; for(int i=0; i<nthreads; ++i) idx_a[i]=0;
    cout << "Testing EoS interpolation at grid points" << endl;
    #pragma omp parallel for schedule(dynamic)
    for (int idx=0; idx<N;++idx)
    {

      int ith = omp_get_thread_num();
      eos[ith].tbqs(800./197., .0, .0, .0, "default");
      auto p = &systemPtr->particles[idx];
      double s_In = p->thermo.s;
      double rhoB_In = p->thermo.rhoB;
      double rhoQ_In = p->thermo.rhoQ;
      double rhoS_In = p->thermo.rhoS;
      bool update_s_success = eos[ith].update_s(s_In, rhoB_In, rhoS_In, rhoQ_In, false);

      ccake::thermodynamic_info thermo;
      if ( update_s_success ) eos[ith].set_thermo( thermo );
      //Check that the EoS is correctly interpolated
      if ( std::abs(thermo.T - systemPtr->particles[idx].thermo.T ) > TOL ){
        #pragma omp critical
        {
        std::cerr << "EoS interpolation failed at point = " << idx << "in  test 2" <<  std::endl;
        std::cerr << "s_rootfinder      = " << std::setprecision(13) << thermo.s << " "
                  << "s_interpolator    = " << std::setprecision(13) << systemPtr->particles[idx].thermo.s << " "
                  << "s_In              = " << std::setprecision(13) << s_In << " " << endl;
        std::cerr << "rhoB_rootfinder   = " << std::setprecision(13) << thermo.rhoB << " "
                  << "rhoB_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoB << " "
                  << "rhoB_In           = " << std::setprecision(13) << rhoB_In << " " << endl;
        std::cerr << "rhoS_rootfinder   = " << std::setprecision(13) << thermo.rhoS << " "
                    << "rhoS_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoS << " "
                    << "rhoS_In           = " << std::setprecision(13) << rhoS_In << " " << endl;
        std::cerr << "rhoQ_rootfinder   = " << std::setprecision(13) << thermo.rhoQ << " "
                  << "rhoQ_interpolator = " << std::setprecision(13) << systemPtr->particles[idx].thermo.rhoQ << " "
                  << "rhoQ_In           = " << std::setprecision(13) << rhoQ_In << " " << endl;
        std::cerr << "T_rootfinder      = " << std::setprecision(13) << thermo.T << " " << endl;
        std::cerr << "T_interpolator    = " << std::setprecision(13) << systemPtr->particles[idx].thermo.T << " " << endl;
        abort();
       }
    }
      //Get end time
      if(ith==0 && idx_a[0]%100==0){
        #pragma omp critical
        {
          int idx_s=0;
          for (int i=1; i<nthreads; ++i) idx_s += idx_a[i];
          end = std::chrono::system_clock::now();
          std::chrono::duration<double> elapsed_seconds = end-start;
          std::cout << "Test 2 progress: " << (double)idx_s/N*100. << "% done. Elapsed time: " << elapsed_seconds.count() << "s";
          std::cout << " Estimated time remaining: " << elapsed_seconds.count()/(double)idx_s*(N-idx_s) << "s" << std::endl;
        }
      }
      idx_a[ith]++;
    }
    cout << "Test 2 passed" << endl;
}


int main(int argc, char* argv[]){
    Kokkos::ScopeGuard scope_guard(argc, argv); //Create Kokkos scope guard to
    // ensure that Kokkos is properly initialized and finalized
    check_args(argc, argv);

    //Setup openMP
    int nthreads = atoi(argv[1]);
    omp_set_num_threads(nthreads);


    //test1(argv[3], argv[2], nthreads);
    test2(argv[3], argv[2], nthreads);
}
