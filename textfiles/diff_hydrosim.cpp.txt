2c2
< #include <iomanip>
---
> #include <iomanip> 
17c17
< #include "hydrosim.h"
---
> #include "hydrosim.h" 
20d19
< #include "bbmg.h"
23c22
< // here the hydro simulation is actually called within the various Simulation subroutines.  First the LinkList is initiated, then the SPH method is used, next we check if any particles have reached freezeout and finally we run Runge Kutta.  The hydro  equations of motion used within Runge Kutta are sent to the function and can be stored in any function you like.
---
> // here the hydro simulation is actually called within the various Simulation subroutines.  First the LinkList is initiated, then the SPH method is used, next we check if any particles have reached freezeout and finally we run Runge Kutta.  The hydro  equations of motion used within Runge Kutta are sent to the function and can be stored in any function you like.  
33c32
< 
---
> 	 
35,36c34,35
< 
< 
---
> 	
> 	
38c37
< 
---
> 	 
40,41c39,40
< 
< 
---
> 	 	
> 	
43c42
< 
---
> 	
45c44
< 
---
> 	
47c46
< 
---
> 	
61c60
< 
---
> 	
65c64
< 
---
> 		
67,69c66,68
<  	   // adams<2>(dt,cc,&idealhydro3<2>,linklist);  // quicker method, not as accurate
<  	    rungeKutta2<2>(dt,&idealhydro3<2>,linklist);  // slower method, more accurate
< 
---
>  	   // adams<2>(dt,cc,&idealhydro3<2>,linklist);  // quicker method, not as accurate	
>  	    rungeKutta2<2>(dt,&idealhydro3<2>,linklist);  // slower method, more accurate	
>  	    
71,73c70,72
< 
< 
< 
---
> 	    
> 	   
> 	   
77c76
< 
---
>  
80c79
<  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
---
>  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check 	    
87,88c86,87
< 
<  	    }
---
>  	    	
>  	    } 	
96,97c95,96
< 
<  	    }
---
>  	    	
>  	    }   
100,101c99,100
< 
< 
---
>   	  
>   	  
103c102
< 
---
> 	
105c104
< 
---
> 	
115,117c114,116
< 
< 
< 
---
> 	 
> 	 
> 	 
121,122c120,121
< 	 linklist.cf=0;
< 
---
> 	 linklist.cf=0;	
> 	
124c123
< 
---
> 	
126c125
< 
---
> 	
141,142c140,141
< 
<  	    if (linklist.cf>0)
---
> 	    
>  	    if (linklist.cf>0) 
154,157c153,156
< 
< // 	    }
< 
< 
---
>  	    	
> // 	    } 		  
>   	  
>   	  
164c163
< 
---
> 	
171,173c170,172
< 
< 
< 
---
> 	 
> 	 
> 	
178c177
< 
---
> 	
180,184c179
< 
< 	BBMG<2> bbmg(linklist);
< 	bbmg.initial(linklist);
< 	cout << "started bbmg" << endl;
< 
---
> 	
187c182
< 
---
> 	
192,194c187,189
< 	  cout << "t=" << linklist.t << " S=" << linklist.S << endl;
< 	  if (linklist.qmf==1) exit(0);
< 	}
---
> 	  cout << "t=" << linklist.t << " S=" << linklist.S << endl; 
> 	
> 	} 
200c195
< 
---
> 	
205,206c200
< 
< 
---
> 		
208,214c202,204
<  		linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " " <<  linklist.Eloss << " " << linklist.S <<  endl;
< 		out.sveprofile(linklist);
< //		out.sveprofile(linklist);
< //		bbmg.propogate(linklist);
< 
< 
---
>  		//cout << "t=" << linklist.t <<endl;
> 		//	out.sveprofile(linklist);
> 	   
216c206
< 
---
>  	    
218a209,210
> 	    cout << "t=" << linklist.t <<endl;                                                                         
> 	          out.sveprofile(linklist);
220,225c212,217
<  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
<  	        linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
<  	    	out.sveprofile(linklist);   // energy density profile
<  	    	cout << "eloss= " << linklist.t << " " <<  linklist.Eloss << endl;
---
> 	    //	       if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
>  	    //{
> 	    //linklist.conservation_entropy();
> 	    //	cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
>  	    //	out.sveprofile(linklist);   // energy density profile
>  	    	
227,228c219,220
< 
<  	    }
---
>  	    	
>  	    //} 	
236,237c228,229
< //
< // 	    }
---
> // 	    	
> // 	    }  
245,250c237,242
< //
< // 	    }
<  	    else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
< 		cout << "t=" <<  linklist.t <<endl;  // outputs time step
<  	    	out.sveprofile(linklist);   // energy density profile
---
> // 	    	
> // 	    }  
>  	    //else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
> 		// {
> 		//cout << "t=" <<  linklist.t <<endl;  // outputs time step
>  	    	//out.sveprofile(linklist);   // energy density profile
254,255c246,247
< 
<  	    }
---
>  	    	
>  	    //} 
263,265c255,257
< //
< // 	    }
< 
---
> // 	    	
> // 	    }    
>   	  
267c259
< 
---
>   	  
271c263
< 
---
> 	
275,381d266
< void BSQSimulation(double dt,LinkList<2> &linklist)
< {
< 	cout << "Ready to start hydrodynamics\n";
< 
< 
< 
< 
< 	 int cc=0;
< 	 linklist.frzc=0;
< 	 linklist.cf=0;
< 
< 
< 	Output<2> out(linklist);
< 
< 	BBMG<2> bbmg(linklist);
< 	bbmg.initial(linklist);
< 	cout << "started bbmg" << endl;
< 
< 	linklist.t=linklist.t0;
< //	out.sveprofile(linklist);
< 
< 	if (linklist.qmf==1||linklist.qmf==3){
< 	  out.bsqsveprofile(linklist);
< 	  cout << "printed first timestep" << endl;
< 	  linklist.conservation_entropy();
< 	  cout << "t=" << linklist.t << " S=" << linklist.S << endl;
< 	  if (linklist.qmf==1) exit(0);
< 	}
< 	else if(linklist.qmf==4){
<           out.eccout(linklist);
< 	  cout << "eccentricity printed" << endl;
< 	  exit(0);
<         }
< 
< 	//out.sveprofile(linklist);
< 	linklist.Ez=0;
< 	while ((linklist.t<linklist.tend)&&(linklist.number_part<linklist.n())) {
< 		linklist.cfon=1;
< 
< 
<  		bsqrungeKutta2<2>(dt,&BSQshear<2>,linklist);
<  		linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " " <<  linklist.Eloss << " " << linklist.S <<  endl;
< 		out.bsqsveprofile(linklist);
< //		out.sveprofile(linklist);
< //		bbmg.propogate(linklist);
< 
< 
<  	    if (linklist.cf>0) out.bsqsvFOprint(linklist);
< 
<  	    if (linklist.qmf==3){
<  	    double tsub=linklist.t-floor(linklist.t);
<  	   // if you add more points to print, must also change LinkList<D>::setup and multiply steps=floor(tend-t0)+1; by the extra number of print offs / 1fm/c
<  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
<  	        linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
<  	    	out.bsqsveprofile(linklist);   // energy density profile
<  	    	cout << "eloss= " << linklist.t << " " <<  linklist.Eloss << endl;
< 		//out.conservation(linklist); // conservation of energy
< 
<  	    }
< // 	    else if ((tsub<(0.2+dt*0.5))&&(tsub>=(0.2-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
< // 	    else if ((tsub<(0.4+dt*0.5))&&(tsub>=(0.4-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
<  	    else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
< 		cout << "t=" <<  linklist.t <<endl;  // outputs time step
<  	    	out.bsqsveprofile(linklist);   // energy density profile
< //		out.conservation(linklist); // conservation of energy
< //		out.gubcheckux(linklist); // gubser test
< //		out.gubcheckuy(linklist); // gubser test
< 
<  	    }
< // 	    else if ((tsub<(0.8+dt*0.5))&&(tsub>=(0.8-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
< 
< 	    }
< 
< 	}
< 	//out.conservation(linklist,pcount);
< 
< 
< 	linklist.endEV();
< }
384,385c269,270
< {
< 	 double t=0.6;
---
> {	
> 	 double t=0.6;	 
388c273
< 
---
> 	
391c276
< 
---
> 	
395,396c280,281
< 
< 
---
> 	
> 	
401,403c286,288
< 
< 
< 
---
>  	    
>  	    
>  	    
407c292
< 
---
>  	    	
412c297
< 
---
>  	    	
414c299
< 
---
>   	  
417c302
< 
---
>  
420c305
< template <int D>
---
> template <int D> 
423,424c308,309
< 
< 
---
>      
>      
426,427c311,312
< 
< 
---
>      
>      	
432,434c317,319
< 
< 	int curfrz=0;
< 	for(int i=0; i<linklist.n(); i++)
---
> 	 
> 	int curfrz=0;	
> 	for(int i=0; i<linklist.n(); i++) 
437c322
< 
---
>                  
439c324
< 
---
>         	
443,444c328,329
< 
< 
---
>         	
> 		
446c331
< 
---
> 	
449c334
< 	linklist.number_part+=curfrz;
---
> 	linklist.number_part+=curfrz;	
453c338
< 
---
> 			
456c341
< 	{
---
> 	{	
466c351
< 
---
> 		
468c353
< 
---
> 	
473c358
< 		linklist.conservation_E();
---
> 		linklist.conservation_E();				
475,478c360,363
< 
< 
< 
< 		//calculate matrix elements
---
> 	
> 	
> 	
> 		//calculate matrix elements		
480,481c365,366
< 	{
< 
---
> 	{	
> 	
489c374
< 
---
> 		
492,495c377,380
< 
< 
< 
< 
---
> 		
> 	
> 		
> 		
503,505c388,390
< 
< 
< 
---
> 		
> 		
> 		
507c392
< 
---
> 		
510c395
< 
---
> 			
513,517c398,402
< 
< 
< 
< 
< 
---
> 	
> 	
> 	
> 	
> 	
520,521c405,406
< 
< template <int D>
---
>  
> template <int D> 
528c413,414
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
---
> 		//		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta)) 
>                 if (linklist._p[i].eta<0) 
531,532c417,418
< 
< 
---
> 			
> 		
544c430
<                     	if (linklist._p[b].eta_sigma<0)
---
>                     	if (linklist._p[b].eta_sigma<0) 
553c439
< 
---
> 		
556c442
< 
---
> 		
559c445
< 	for(int i=0; i<linklist.n(); i++)
---
> 	for(int i=0; i<linklist.n(); i++) 
562c448
< 
---
>                  
569c455
< 	linklist.number_part+=curfrz;
---
> 	linklist.number_part+=curfrz;		
572c458
< 	int m=0;
---
> 	int m=0;	
574c460
< 	{
---
> 	{	
578c464
< 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1))
---
> 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1)) 
584c470
< 
---
> 			
586c472
< 
---
> 	
589,592c475,478
< 
< 
< 
< 		//calculate matrix elements
---
> 	
> 	
> 	
> 		//calculate matrix elements		
594,596c480,482
< 	{
< 
< 
---
> 	{	
> 	
> 	
604c490
< 
---
> 		
607,609c493,495
< 
< 
< 
---
> 		
> 		
> 		
611c497
< 
---
> 		
618c504
< 
---
> 		
620d505
< 
622d506
< 
624d507
< 
626c509
< 
---
>         	
629c512
< 
---
> 		
631c514
< 
---
> 	
633,635c516,518
< 
< 
< 
---
> 	
> 	
> 	
638,639c521,522
< 
<  template <int D>
---
>  
>  template <int D> 
642a526
> 	
644c528
< 
---
>     
647a532,533
> 	
> 		
649,650c535
< 
< 
---
>      
653a539
> 		
655,656c541,542
< 
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
---
> 		//		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta)) 
> 		if (linklist._p[i].eta<0)
659c545
< 
---
> 			
676,677c562,563
< //
< //
---
> //			
> //                    	
683c569
< //
---
> //			
686c572
< 
---
> 		
688,689c574
< 
< 
---
> 	
691c576
< 	for(int i=0; i<linklist.n(); i++)
---
> 	for(int i=0; i<linklist.n(); i++) 
694c579
< 
---
>                  
698c583
< 
---
>         		
702c587
< 	linklist.number_part+=curfrz;
---
> 	linklist.number_part+=curfrz;		
705,706c590,591
< 
< 	int m=0;
---
> 	
> 	int m=0;	
708c593
< 	{
---
> 	{	
712c597
< 
---
> 		
714c599
< 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1))
---
> 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1)) 
720c605
< 
---
> 			
722c607
< 
---
> 	
725,727c610,612
< 
< 
< 		//calculate matrix elements
---
> 	
> 	
> 		//calculate matrix elements		
729c614
< 	{
---
> 	{	
734c619
< 		Vector<double,D>  minshv=rowp1(0,linklist._p[i].shv);
---
> 		Vector<double,D>  minshv=rowp1(0,linklist._p[i].shv);		
743,744c628,629
< 
< 
---
> 		
> 		
751,754c636,637
< 		linklist._p[i].du_dt.x[0]=(F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1]);
< 		linklist._p[i].du_dt.x[1]=(F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1]);
< 
< 
---
> 		linklist._p[i].du_dt.x[0]=F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1];
> 		linklist._p[i].du_dt.x[1]=F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1];
755a639
> 		
756a641
> 		
762c647
< 
---
> 		
765,766c650,651
< 
< 
---
> 		
> 		
768,769c653,654
< 
< 
---
> 		
> 		
772,775c657,660
< 
< 
< 
< 
---
> 		
> 		
> 		
> 		
777c662
< 
---
>         	
779c664
< 
---
>          	 
783,784c668,669
< 
< 
---
> 		
> 		
786,787c671,672
< 
< 
---
> 	
> 	
789,790c674,675
< 
< 
---
> 	
> 	
791a677
> 	
794,884d679
< template <int D>
< void BSQshear(LinkList<D>  &linklist)  // shear+bulk Equations of motion, only set up completely for 2+1 at the moment
< {
< 
< 
< 
<      linklist.setshear();
<      linklist.initiate();
< 
< 
< 
< 
<      	for(int i=0; i<linklist.n();i++)
< 	{
< 		int curfrz=0;//added by Christopher Plumberg to get compilation
< 		linklist.bsqsvoptimization2(i,linklist.t,curfrz);
< 		if (true){std::cerr << "Fix this! " <<__FILE__ << ":" << __LINE__ << std::endl;  exit(8);}
< 
< 
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
< 		{
< 			cout << i <<  " neg entropy " <<  linklist._p[i].EOS.T()*197.3   << " " << linklist._p[i].eta << endl;
< 
< 			linklist._p[i].eta=0;
< 
< //			 int a,b;
< //			 a=i;
< //			double sigma = 0.;
< //    			Vector<int,D> ii;
< //			for(ii.x[0]=-2; ii.x[0]<=2; ii.x[0]++)
< //        		{
< //        		for(ii.x[1]=-2; ii.x[1]<=2; ii.x[1]++)
< //        		{
< 
< //                 	b=linklist.lead[linklist.triToSum(linklist.dael[a]+ii, linklist.size)];
< //                 	while(b!=-1 )
< //                 	{
< //                 	double kern=linklist.kernel(linklist._p[b].r-linklist._p[a].r);
< //                    	sigma = sigma + linklist._p[b].sigmaweight*kern;
< //
< //
< //                   	b=linklist.link[b];
< //                   	}
< //        		}
< //			}
< //			cout << "final entropy=" << sigma << " eta_sigma=" << linklist._p[a].eta_sigma << " r=" << linklist._p[a].r << endl;
< //
< //			exit(1);
< 		}
< 
< 	}
< 
< 
< 	int curfrz=0;
< 	for(int i=0; i<linklist.n(); i++)
< 	{
<                  //  Computes gamma and velocity
< 
<         	linklist._p[i].calcbsq(linklist.t); //resets EOS!!
< 		linklist._p[i].setvisc(linklist.etaconst,linklist.bvf,linklist.svf,linklist.zTc,linklist.sTc,linklist.zwidth,linklist.visc);
< 		if (linklist.cfon==1) linklist._p[i].frzcheck(linklist.t,curfrz,linklist.n());
< 
< 	}
< 	if (linklist.cfon==1)
< 	{
< 	linklist.number_part+=curfrz;
< 	linklist.list.resize(curfrz);
< 	}
< 
< 	int m=0;
< 	for(int i=0; i<linklist.n();i++)
< 	{
< 		//      Computes gradients to obtain dsigma/dt
< 		//linklist.bsqoptimization2(i,linklist.t,curfrz);
<                 linklist.bsqsvoptimization2(i,linklist.t,curfrz); //added by C. Plumberg
<                 if (true){std::cerr << "Fix this! " <<__FILE__ << ":" << __LINE__ << std::endl;  exit(8);}
< 		linklist._p[i].dsigma_dt = -linklist._p[i].sigma*(linklist._p[i].gradV.x[0][0]+linklist._p[i].gradV.x[1][1]) ;
< 
< 		linklist._p[i].bsqsvsigset(linklist.t,i);
< 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1))
< 		{
< 			linklist.list[m]=i;
< 			linklist._p[i].Freeze=4;
< 			++m;
< 		}
< 
< 	}
< 
< 	if (linklist.rk2==1) linklist.bsqsvconservation();
< 	linklist.bsqsvconservation_Ez();
< 
886,953d680
< 		//calculate matrix elements
< 	for(int i=0; i<linklist.n();i++)
< 	{
< 		double gamt=1./linklist._p[i].gamma/linklist._p[i].stauRelax;
< 		double pre=linklist._p[i].eta_o_tau/2./linklist._p[i].gamma;
< 		//p4=gamt-linklist._p[i].sigl*4./3.;
< 		double p1=gamt-4./3./linklist._p[i].sigma*linklist._p[i].dsigma_dt+1./linklist.t/3.;
< 		Vector<double,D>  minshv=rowp1(0,linklist._p[i].shv);
< 		//p2=linklist._p[i].setas*gamt;
< 		Matrix <double,D,D> partU=linklist._p[i].gradU+transpose(linklist._p[i].gradU);
< 
< 		// set the Mass and the Force
< 		Matrix <double,D,D> M=linklist._p[i].Msub(i);
< 		Vector<double,D> F=linklist._p[i].Btot*linklist._p[i].u+ linklist._p[i].gradshear -(linklist._p[i].gradP+linklist._p[i].gradBulk+ linklist._p[i].divshear);
< 		// shear contribution
< 		F+=pre*linklist._p[i].v*partU+p1*minshv;
< 
< 
< 		double det=deter(M);
< 		Matrix <double,D,D> MI;
< 		MI.x[0][0]=M.x[1][1]/det;
< 		MI.x[0][1]=-M.x[0][1]/det;
< 		MI.x[1][0]=-M.x[1][0]/det;
< 		MI.x[1][1]=M.x[0][0]/det;
< 		linklist._p[i].du_dt.x[0]=F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1];
< 		linklist._p[i].du_dt.x[1]=F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1];
< 
< 
< 
< 
< 		Matrix <double,D,D> ulpi=linklist._p[i].u*colp1(0,linklist._p[i].shv);
< 
< 		double vduk=inner(linklist._p[i].v,linklist._p[i].du_dt);
< 
< 		Matrix <double,D,D> Ipi=-linklist._p[i].eta_o_tau/3.*(linklist._p[i].Imat+linklist._p[i].uu)+4./3.*linklist._p[i].pimin;
< 
<         	linklist._p[i].div_u = (1./ linklist._p[i].gamma)*inner( linklist._p[i].u, linklist._p[i].du_dt) - ( linklist._p[i].gamma/ linklist._p[i].sigma)* linklist._p[i].dsigma_dt ;
< 		linklist._p[i].bigtheta=linklist._p[i].div_u*linklist.t+linklist._p[i].gamma;
< 
< 
< 		Matrix <double,D,D> sub=linklist._p[i].pimin+linklist._p[i].shv.x[0][0]/linklist._p[i].g2*linklist._p[i].uu-1./linklist._p[i].gamma*linklist._p[i].piutot;
< 
< 
< 		linklist._p[i].inside=linklist.t*(inner((-minshv+linklist._p[i].shv.x[0][0]*linklist._p[i].v),linklist._p[i].du_dt)- con2(sub,linklist._p[i].gradU)    -      linklist._p[i].gamma*linklist.t*linklist._p[i].shv33);
< 		linklist._p[i].detasigma_dt =1./linklist._p[i].sigma/linklist._p[i].EOS.T()*( -linklist._p[i].bigPI*linklist._p[i].bigtheta+linklist._p[i].inside);
< 
< 
< 
< 
<         	linklist._p[i].dBulk_dt = (-linklist._p[i].zeta/linklist._p[i].sigma*linklist._p[i].bigtheta - linklist._p[i].Bulk/linklist._p[i].gamma )/linklist._p[i].tauRelax;
< 
<         	Matrix <double,D,D> ududt=linklist._p[i].u*linklist._p[i].du_dt;
< 
< 
<         	linklist._p[i].dshv_dt= -gamt*(linklist._p[i].pimin+linklist._p[i].setas*0.5*partU)-0.5*linklist._p[i].eta_o_tau*(ududt+transpose(ududt))+linklist._p[i].dpidtsub()-vduk*(ulpi+transpose(ulpi)+(1/linklist._p[i].gamma)*Ipi)+linklist._p[i].sigl*Ipi;
< 
< 		      linklist._p[i].drhoB_dt=-linklist._p[i].rhoB*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 					linklist._p[i].drhoS_dt=-linklist._p[i].rhoS*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 					linklist._p[i].drhoQ_dt=-linklist._p[i].rhoQ*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 
< 	}
< 
< 
< 	if (linklist.cfon==1) linklist.bsqsvfreezeout(curfrz);
< 
< 
< 	linklist.destroy();
<  }
20d19
< #include "bbmg.h"
181,184d179
< 	BBMG<2> bbmg(linklist);
< 	bbmg.initial(linklist);
< 	cout << "started bbmg" << endl;
< 
193c188
< 	  if (linklist.qmf==1) exit(0);
---
> 	
206d200
< 
208,213c202,203
<  		linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " " <<  linklist.Eloss << " " << linklist.S <<  endl;
< 		out.sveprofile(linklist);
< //		out.sveprofile(linklist);
< //		bbmg.propogate(linklist);
< 
---
>  		//cout << "t=" << linklist.t <<endl;
> 		//	out.sveprofile(linklist);
218a209,210
> 	    cout << "t=" << linklist.t <<endl;                                                                         
> 	          out.sveprofile(linklist);
220,226c212,216
<  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
<  	        linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
<  	    	out.sveprofile(linklist);   // energy density profile
<  	    	cout << "eloss= " << linklist.t << " " <<  linklist.Eloss << endl;
< 		//out.conservation(linklist); // conservation of energy
---
> 	    //	       if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
>  	    //{
> 	    //linklist.conservation_entropy();
> 	    //	cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
>  	    //	out.sveprofile(linklist);   // energy density profile
228,333d217
<  	    }
< // 	    else if ((tsub<(0.2+dt*0.5))&&(tsub>=(0.2-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
< // 	    else if ((tsub<(0.4+dt*0.5))&&(tsub>=(0.4-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
<  	    else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
< 		cout << "t=" <<  linklist.t <<endl;  // outputs time step
<  	    	out.sveprofile(linklist);   // energy density profile
< //		out.conservation(linklist); // conservation of energy
< //		out.gubcheckux(linklist); // gubser test
< //		out.gubcheckuy(linklist); // gubser test
< 
<  	    }
< // 	    else if ((tsub<(0.8+dt*0.5))&&(tsub>=(0.8-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
< // 	    {
< //		cout << "t=" <<  linklist.t <<endl;  // outputs time step
< // 	    	out.sveprofile(linklist);   // energy density profile
< ////		out.conservation(linklist); // conservation of energy
< ////		out.gubcheckux(linklist); // gubser test
< ////		out.gubcheckuy(linklist); // gubser test
< //
< // 	    }
< 
< 	    }
< 
< 	}
< 	//out.conservation(linklist,pcount);
< 
< 
< 	linklist.endEV();
< }
< 
< void BSQSimulation(double dt,LinkList<2> &linklist)
< {
< 	cout << "Ready to start hydrodynamics\n";
< 
< 
< 
< 
< 	 int cc=0;
< 	 linklist.frzc=0;
< 	 linklist.cf=0;
< 
< 
< 	Output<2> out(linklist);
< 
< 	BBMG<2> bbmg(linklist);
< 	bbmg.initial(linklist);
< 	cout << "started bbmg" << endl;
< 
< 	linklist.t=linklist.t0;
< //	out.sveprofile(linklist);
< 
< 	if (linklist.qmf==1||linklist.qmf==3){
< 	  out.bsqsveprofile(linklist);
< 	  cout << "printed first timestep" << endl;
< 	  linklist.conservation_entropy();
< 	  cout << "t=" << linklist.t << " S=" << linklist.S << endl;
< 	  if (linklist.qmf==1) exit(0);
< 	}
< 	else if(linklist.qmf==4){
<           out.eccout(linklist);
< 	  cout << "eccentricity printed" << endl;
< 	  exit(0);
<         }
< 
< 	//out.sveprofile(linklist);
< 	linklist.Ez=0;
< 	while ((linklist.t<linklist.tend)&&(linklist.number_part<linklist.n())) {
< 		linklist.cfon=1;
< 
< 
<  		bsqrungeKutta2<2>(dt,&BSQshear<2>,linklist);
<  		linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " " <<  linklist.Eloss << " " << linklist.S <<  endl;
< 		out.bsqsveprofile(linklist);
< //		out.sveprofile(linklist);
< //		bbmg.propogate(linklist);
< 
< 
<  	    if (linklist.cf>0) out.bsqsvFOprint(linklist);
< 
<  	    if (linklist.qmf==3){
<  	    double tsub=linklist.t-floor(linklist.t);
<  	   // if you add more points to print, must also change LinkList<D>::setup and multiply steps=floor(tend-t0)+1; by the extra number of print offs / 1fm/c
<  	    if (tsub<(0.0+dt*0.99)||(tsub>=1-+dt*0.99)) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
<  	        linklist.conservation_entropy();
< 		cout << "t=" << linklist.t << " S=" << linklist.S << endl;  // outputs time step
<  	    	out.bsqsveprofile(linklist);   // energy density profile
<  	    	cout << "eloss= " << linklist.t << " " <<  linklist.Eloss << endl;
336c220
<  	    }
---
>  	    //} 	
355,358c239,242
<  	    else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
<  	    {
< 		cout << "t=" <<  linklist.t <<endl;  // outputs time step
<  	    	out.bsqsveprofile(linklist);   // energy density profile
---
>  	    //else if ((tsub<(0.5+dt*0.5))&&(tsub>=(0.5-+dt*0.5))) // uncomment if you want to observe energydensity profile, conservation of energy or do a Gubser check
> 		// {
> 		//cout << "t=" <<  linklist.t <<endl;  // outputs time step
>  	    	//out.sveprofile(linklist);   // energy density profile
363c247
<  	    }
---
>  	    //} 
382a267
> 
528c413,414
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
---
> 		//		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta)) 
>                 if (linklist._p[i].eta<0) 
620d505
< 
622d506
< 
624d507
< 
644a528
>     
650a535
>      
656c541,542
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
---
> 		//		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta)) 
> 		if (linklist._p[i].eta<0)
689d574
< 
751,752c636,637
< 		linklist._p[i].du_dt.x[0]=(F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1]);
< 		linklist._p[i].du_dt.x[1]=(F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1]);
---
> 		linklist._p[i].du_dt.x[0]=F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1];
> 		linklist._p[i].du_dt.x[1]=F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1];
792,878d676
<  }
< 
< template <int D>
< void BSQshear(LinkList<D>  &linklist)  // shear+bulk Equations of motion, only set up completely for 2+1 at the moment
< {
< 
< 
< 
<      linklist.setshear();
<      linklist.initiate();
< 
< 
< 
< 
<      	for(int i=0; i<linklist.n();i++)
< 	{
< 		int curfrz=0;//added by Christopher Plumberg to get compilation
< 		linklist.bsqsvoptimization2(i,linklist.t,curfrz);
< 		if (true){std::cerr << "Fix this! " <<__FILE__ << ":" << __LINE__ << std::endl;  exit(8);}
< 
< 
< 		if ((linklist._p[i].eta<0)||isnan(linklist._p[i].eta))
< 		{
< 			cout << i <<  " neg entropy " <<  linklist._p[i].EOS.T()*197.3   << " " << linklist._p[i].eta << endl;
< 
< 			linklist._p[i].eta=0;
< 
< //			 int a,b;
< //			 a=i;
< //			double sigma = 0.;
< //    			Vector<int,D> ii;
< //			for(ii.x[0]=-2; ii.x[0]<=2; ii.x[0]++)
< //        		{
< //        		for(ii.x[1]=-2; ii.x[1]<=2; ii.x[1]++)
< //        		{
< 
< //                 	b=linklist.lead[linklist.triToSum(linklist.dael[a]+ii, linklist.size)];
< //                 	while(b!=-1 )
< //                 	{
< //                 	double kern=linklist.kernel(linklist._p[b].r-linklist._p[a].r);
< //                    	sigma = sigma + linklist._p[b].sigmaweight*kern;
< //
< //
< //                   	b=linklist.link[b];
< //                   	}
< //        		}
< //			}
< //			cout << "final entropy=" << sigma << " eta_sigma=" << linklist._p[a].eta_sigma << " r=" << linklist._p[a].r << endl;
< //
< //			exit(1);
< 		}
< 
< 	}
< 
< 
< 	int curfrz=0;
< 	for(int i=0; i<linklist.n(); i++)
< 	{
<                  //  Computes gamma and velocity
< 
<         	linklist._p[i].calcbsq(linklist.t); //resets EOS!!
< 		linklist._p[i].setvisc(linklist.etaconst,linklist.bvf,linklist.svf,linklist.zTc,linklist.sTc,linklist.zwidth,linklist.visc);
< 		if (linklist.cfon==1) linklist._p[i].frzcheck(linklist.t,curfrz,linklist.n());
< 
< 	}
< 	if (linklist.cfon==1)
< 	{
< 	linklist.number_part+=curfrz;
< 	linklist.list.resize(curfrz);
< 	}
< 
< 	int m=0;
< 	for(int i=0; i<linklist.n();i++)
< 	{
< 		//      Computes gradients to obtain dsigma/dt
< 		//linklist.bsqoptimization2(i,linklist.t,curfrz);
<                 linklist.bsqsvoptimization2(i,linklist.t,curfrz); //added by C. Plumberg
<                 if (true){std::cerr << "Fix this! " <<__FILE__ << ":" << __LINE__ << std::endl;  exit(8);}
< 		linklist._p[i].dsigma_dt = -linklist._p[i].sigma*(linklist._p[i].gradV.x[0][0]+linklist._p[i].gradV.x[1][1]) ;
< 
< 		linklist._p[i].bsqsvsigset(linklist.t,i);
< 		if ((linklist._p[i].Freeze==3)&&(linklist.cfon==1))
< 		{
< 			linklist.list[m]=i;
< 			linklist._p[i].Freeze=4;
< 			++m;
< 		}
882,883d679
< 	if (linklist.rk2==1) linklist.bsqsvconservation();
< 	linklist.bsqsvconservation_Ez();
885,953d680
< 
< 		//calculate matrix elements
< 	for(int i=0; i<linklist.n();i++)
< 	{
< 		double gamt=1./linklist._p[i].gamma/linklist._p[i].stauRelax;
< 		double pre=linklist._p[i].eta_o_tau/2./linklist._p[i].gamma;
< 		//p4=gamt-linklist._p[i].sigl*4./3.;
< 		double p1=gamt-4./3./linklist._p[i].sigma*linklist._p[i].dsigma_dt+1./linklist.t/3.;
< 		Vector<double,D>  minshv=rowp1(0,linklist._p[i].shv);
< 		//p2=linklist._p[i].setas*gamt;
< 		Matrix <double,D,D> partU=linklist._p[i].gradU+transpose(linklist._p[i].gradU);
< 
< 		// set the Mass and the Force
< 		Matrix <double,D,D> M=linklist._p[i].Msub(i);
< 		Vector<double,D> F=linklist._p[i].Btot*linklist._p[i].u+ linklist._p[i].gradshear -(linklist._p[i].gradP+linklist._p[i].gradBulk+ linklist._p[i].divshear);
< 		// shear contribution
< 		F+=pre*linklist._p[i].v*partU+p1*minshv;
< 
< 
< 		double det=deter(M);
< 		Matrix <double,D,D> MI;
< 		MI.x[0][0]=M.x[1][1]/det;
< 		MI.x[0][1]=-M.x[0][1]/det;
< 		MI.x[1][0]=-M.x[1][0]/det;
< 		MI.x[1][1]=M.x[0][0]/det;
< 		linklist._p[i].du_dt.x[0]=F.x[0]*MI.x[0][0]+F.x[1]*MI.x[0][1];
< 		linklist._p[i].du_dt.x[1]=F.x[0]*MI.x[1][0]+F.x[1]*MI.x[1][1];
< 
< 
< 
< 
< 		Matrix <double,D,D> ulpi=linklist._p[i].u*colp1(0,linklist._p[i].shv);
< 
< 		double vduk=inner(linklist._p[i].v,linklist._p[i].du_dt);
< 
< 		Matrix <double,D,D> Ipi=-linklist._p[i].eta_o_tau/3.*(linklist._p[i].Imat+linklist._p[i].uu)+4./3.*linklist._p[i].pimin;
< 
<         	linklist._p[i].div_u = (1./ linklist._p[i].gamma)*inner( linklist._p[i].u, linklist._p[i].du_dt) - ( linklist._p[i].gamma/ linklist._p[i].sigma)* linklist._p[i].dsigma_dt ;
< 		linklist._p[i].bigtheta=linklist._p[i].div_u*linklist.t+linklist._p[i].gamma;
< 
< 
< 		Matrix <double,D,D> sub=linklist._p[i].pimin+linklist._p[i].shv.x[0][0]/linklist._p[i].g2*linklist._p[i].uu-1./linklist._p[i].gamma*linklist._p[i].piutot;
< 
< 
< 		linklist._p[i].inside=linklist.t*(inner((-minshv+linklist._p[i].shv.x[0][0]*linklist._p[i].v),linklist._p[i].du_dt)- con2(sub,linklist._p[i].gradU)    -      linklist._p[i].gamma*linklist.t*linklist._p[i].shv33);
< 		linklist._p[i].detasigma_dt =1./linklist._p[i].sigma/linklist._p[i].EOS.T()*( -linklist._p[i].bigPI*linklist._p[i].bigtheta+linklist._p[i].inside);
< 
< 
< 
< 
<         	linklist._p[i].dBulk_dt = (-linklist._p[i].zeta/linklist._p[i].sigma*linklist._p[i].bigtheta - linklist._p[i].Bulk/linklist._p[i].gamma )/linklist._p[i].tauRelax;
< 
<         	Matrix <double,D,D> ududt=linklist._p[i].u*linklist._p[i].du_dt;
< 
< 
<         	linklist._p[i].dshv_dt= -gamt*(linklist._p[i].pimin+linklist._p[i].setas*0.5*partU)-0.5*linklist._p[i].eta_o_tau*(ududt+transpose(ududt))+linklist._p[i].dpidtsub()-vduk*(ulpi+transpose(ulpi)+(1/linklist._p[i].gamma)*Ipi)+linklist._p[i].sigl*Ipi;
< 
< 		      linklist._p[i].drhoB_dt=-linklist._p[i].rhoB*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 					linklist._p[i].drhoS_dt=-linklist._p[i].rhoS*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 					linklist._p[i].drhoQ_dt=-linklist._p[i].rhoQ*linklist._p[i].sigma*linklist._p[i].bigtheta;
< 
< 	}
< 
< 
< 	if (linklist.cfon==1) linklist.bsqsvfreezeout(curfrz);
< 
< 
< 	linklist.destroy();
<  }
